using System;

namespace CODE_BLOG__4__приведение_и_преобразование_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Приведение и преобразование типов C# - Учим Шарп #4
            /*
            Основные нотации:
            string UpperCamelCase;   // верхняя верблющья нотация - применяется в C# для именования классов, свойств, методов
            string lpperCamelCase;   // нижня верблющья нотация   - применяется в C# для именования переменных(обычных, локальных)
            string snake_case;       // змеиная нотация - применяется в джаваскрипте
            string FAT_SNAKE_CASE;   // толстая змеиная нотация - применяется для именования констант
            string snake_case;       // змеиная нотация
            string kebab-case;       // шашлычная нотация - в C# применять нельзя, используется в языке Лиск
            string sHungaryCase;     // вингерская нотация - первая буква обозначает тип переменной - эта нотация не в ходу, тк 
                                     // тип переменной можно посмотреть просто наведя мышкой на саму переменную.

            */
            //Так как язык строго типизированный, нам иногда нужно приводить типы из одного в другой.





            // ПРИВЕДЕНИЕ ТИПОВ
            /*
            // НЕ ЯВНОЕ ПРИВЕДЕНИЕ ТИПОВ
            int j = 5;
            double d = j;   // нет ошибки - тк int меньше double


            // ЯВНОЕ ПРИВЕДЕНИЕ ТИПОВ
            double dd = j;   // нет ошибки - тк int меньше double
            //int k = d;    // ошибка - double в int неявно привести мы не можем, тк одни типы больше других и мы не можем посадить
            // слона в ведро.
            int k = (int)dd; // тут мы сделали явное приведение, тем самым расписались лично как программист за данное действие.
            //Console.WriteLine(k);

            // ЯВНОЕ ПРИВЕДЕНИЕ ТИПОВ + кладем 2055 в byte (дракон пытается залезть на осла)
            int j1 = 2055;      // если тут будет 2047 то на консоль выведется 255, если 2048 выведется 0, если 2055 то выведется 7.
            byte bb = (byte)j1; // тоесть у нас происходит что значение идет по кругу до тех пор пока не будет достигнуто значение.
                                //Console.WriteLine(bb);  // тоесть идет от 0 до 255, далее снова от 0 до 255 и так бегает по кругу пока не достигнет своего
                                // значения.
                                // И на этапе компиляции при данных ситуациях компилятор нам ничего не скажет, тут нужно быть осторожным в работе!!!
                                // Подобные ошибки сложно отлавливаемые, потому что значения будут валидны.
            */






            // ПРЕОБРАЗОВАНИЕ ТИПОВ
            /*
            // НЕ ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ
            // Данное преобразование зачастую происходит при работе со строками. Н/П: мы объявляем целочисленную переменную и потом
            // объединяем ее со строкой.
            int i7 = 1;
            string s22 = "str" + i7;    // таким образом у нас будет НЕ ЯВНОЕ преобразование целочисленной переменной к строке.
            Console.WriteLine(s22.GetType()); // это возможно, потому, что все в языке C# наследуется от типа object и у это типа 
            Console.WriteLine(s22);           // object есть метод ToString(), соответственно этот метод ToString() есть абсолютно
                                              //у каждого объекта в C#. И поэтому всегда мы можем преобразовать все в строковый формат.
            //string s22 = "str" + i7.ToString();    //еще можно было бы написать таким образом, но это уже считалось бы как ЯВНОЕ
                                                     // преобразование. 



            
            // ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПОВ
            string s = "100";
            //int i = s;    // ошибка - тк в данном случае мы не можем сделать даже ЯВНОЕ приведение, и тут нам поможет только
                            // преобразование типов.
            // Преобразование типов - немного сложнее операция чем приведение, она выполняется при помощи специального класса Convert.
            int i = Convert.ToInt32(s); // Преобразование способ 1
            Console.WriteLine(i.GetType()); // тут показали что тип стал int
            Console.WriteLine(i);

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||");

            int i2 = int.Parse(s); // Преобразование способ 2
            Console.WriteLine(i2.GetType()); // тут показали что тип стал int
            Console.WriteLine(i2);
            */



            //немного практики от Вопросов

            // ЯВНОЕ ПРЕОБРАЗОВАНИЕ с bool
            string a10 = "true";
            bool a20 = Convert.ToBoolean(a10);
            Console.WriteLine(a20.GetType());
            Console.WriteLine(a20);

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||");

            int result;
            if (int.TryParse("123", out result))    // если получится привести "123" к int, то выполнится тело if и результат 
            {                                       // приведения у нас будет лежать в перименной result
                Console.WriteLine(result.GetType());
                Console.WriteLine(result);
            }
            // почему не используем тут Try Catch - тк нужно отлавлдивать то что нужно, а делать Try Catch и просто глушить исключения
            // это плохая идея.



        }
    }
}
