using System;

namespace CODE_BLOG__29_Базовый_тип_Object
{
    class Point
    {
        public int X { get; set; }
        public MyClass MyClass { get; set; }
        public Point Y { get; set; }


        // Переопределеям поведение метода Equals()
        public override bool Equals(object obj) // никогда этот метод не должен выкидывать эксепшон!!!
        {
            /*
            // если на вход поступает null, метод должен возвращать false, но помним, что null равен null а это плохо, тк null принимать нельзя
            if (obj == null) return false;

            // проверка на совпадение типов
            // 2 операции is и as:
            // is - возвращает bool значение если этот тип является тем же типом с которым мы сравниваем, например if(obj is Point) - тут
            // будет проверка, является ли пришедший obj параметр Point'ом, если да то true, если нет то false.
            // as - подобна is за исключением того, что она возвращает ссылку на целевой тип. Поскольку гарантируется, что она никогда
            // не сгенерирует исключения, здесь просто возвращается null - ссылка, если данное преобразование невозможно.
            var point = obj as Point;

            if (point != null) //проверка на null
            {
            }
            else 
            {  return false; }
            */

            //весь код выше упрощается до данного кода, тут проверка на null, и проверка на совпадение типов
            if (obj is Point point) //тут если obj является Point, то сразу переменную привести и положить в переменную point, если нет то false
            {
                //и внутри этого блока мы можем работать с point, и выполнять сравнения так как нам нужно
                return point.X == X;
            }
            else
            {
                return false;
            }
        }
        // Итого - если мы хотим для нашего ссылочного типа переопределить метод сравнения Equals(), если мы хотим обеспечить такое поведение
        // когда мы сравниваем не по адресу памяти, а по каким либо определенным значениям. И выше мы так и сделали, сравнение по переменной
        // X, если они у двух ссылочных объектов будут они равны, то метод Equals выдаст true.






        // При переопределении GetHashCode() лучше всего основываясь на данных возвращать Х, это какой то оператор сравнения, операция
        // позволяет быстро вычислить целочисленный идентификатор определяющий этот объект и определить выполнить первоначальную проверку
        // на равенство.
        public override int GetHashCode() //
        {
            return X;
        }

        //переопределяем метод ToString
        public override string ToString() //это приведение к строке
        {
            return X.ToString();
        }




        
        // не глубокое клонирование
        public Point Clone()
        {
            return MemberwiseClone() as Point;  // делаем приведение вот так "as Point", тк MemberwiseClone() возвращает по умолчанию 
                                                // тип object.
        }
        
        /*
        // глубокое клонирование
        public Point Clone()
        {
            var resut = (Point)MemberwiseClone();  //MemberwiseClone() при клонировании нам возвращает object, а нам нужен Point, делаем
                                                   //приведение.
            return resut.Y = Y.Clone();
        }
        */


    }
}
