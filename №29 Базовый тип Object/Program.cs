using System;

namespace CODE_BLOG__29_Базовый_тип_Object
{
    class Program : System.Object   //так писать не нужно, тк это наследование производится неявно
    {
        static void Main(string[] args)
        {
            // Базовый тип Object в C# - Учим Шарп #29
            /*
            Object изнаячально является базовым классом от которого наследуются все типы в C# и .NET. Это значит, что с чем бы мы не 
            столкнулись, мы сможем привести любой тип к Object. Это может быть базовый тип, это может быть любой написанный нами класс, 
            так же все значимые типы наследуются от Object. Тоесть все значимые типы int, char, struct все базовые примитивы, все это 
            наследуется от Object и мы их можем приводить к Object. Это сделано для того чтобы все привести к общей основе.
            Тип Object распологается в пространстве имен "using System".

            Псевдонимы:
            System.Object == object
            System.Int64 == int
            */

            // Когда мы создаем переменную типа Object, мы видим у нее самые базовые методы, Equals(), GetHashCode(), GetType(), ToString().
            object obj = new object();
            //obj.;   //тут мы видим те самые 4 базовых метода у объекта obj, эти методы есть абсолютно у всех объектов в C#, тк все
            //наследуеться от Object. В классе class Program : System.Object так писать не нужно, тк это наследование
            //производится неявно, нам не нужно это писать, за нас это делает платформа .NET.

            /*
            Equals() - выполняет сравнение двух объектов, для значимых и ссылочных типов сравнивает по разному:
                        - для значимых типов сравнение по значению
                        - для ссылочных типов сравнение по адресам на объекты в куче, и даже если это будут одинаковые объекты
                          с одинаковыми внутренними значениями, но они будут распологаться в различных областях памяти то мы получим false.
                          Для проверки этой теории делаем упаковку и распаковку объектов.




            Упаковка и распаковка объекта (boxing unboxing)
            Зачем вообще делать упаковку, распаковку - к примеру мы постоянно работаем со значимыми типами, и когда мы передаем значимую
            переменную в метод, то в метод попадет ее копия и в методе работа будет проходить с копией и чтобы такого не происходило
            мы можем преобразовать переменную в ссылочный тип, тоесть сделать boxing и не мучиться с постоянным копированием переменной 
            в методах и так же нам не придется каждый раз использовать ref для переменной которую передаем в метод. ref - это передача
            значения в метод по ссылке.

            boxing - это когда у нас есть значимые типы, и мы можем помещать их в кучу, тоесть переносить их из стека в кучу. Это делается
            элементарным приведением к object.

            unboxing - 
            */



            // ДАЛЕЕ если мы смотрим в класс object(нажатием F12), мы видим что там внутри 7 методов, так же есть конструктор и деструктор.
            // Все virtual(можно переопределять) методы относятся к экземплярам класса, и 2 метода static(нельзя переопределять) относятся
            // ко всему классу.


            Console.WriteLine("||||||3 virtual метода Object");


            Console.WriteLine("||||||Equals() - virtual");
            // Equals() сравнение значимого типа
            int i = 5;
            int j = 5;
            Console.WriteLine(i.Equals(j));

            // boxing 1 сравнение ссылочного типа 1 (кривой пример)
            object oi = (object)i;  //тут мы выполнили упаковку и теперь они храняться в куче
            object oj = (object)j; 
            Console.WriteLine(oi.Equals(oj));   //тут должно быть false, но выводится true тк среда что то понимает .......хз что

            // boxing 2 сравнение ссылочного типа 2 (первый раз по адресам памяти и после переопределили метод и сравнили ссылочный тип
            // по значению которое было внутри него)
            var p1 = new Point() { X = 5 };
            var p2 = new Point() { X = 5 };
            Console.WriteLine(p1.Equals(p2));   //тут false как и должно быть, 2 одинаковых объекта с одинаковым содержимым лежат в разных
                                                //областях памяти и поэтому false. Но в классе Point мы переопределили метод Equals и
                                                //реализовали сравнение не по адресам в памяти как это идет по дефолту, а по конкретному
                                                //значению, и там мы сравниваем значения X, а тк у нас они равны, теперь тут будет true.




            Console.WriteLine("||||||GetHashCode() - virtual");
            // GetHashCode() - это Equals() на минималках, суть операции GetHashCode() это то, что она должна быть максимально быстрой.
            // Используется, в словарях, хеш таблицах, для быстрого поиска объекта по идентификатору. Самое интересное в GetHashCode(), это
            // то, что он не должен быть равнозначным, вполне возможно возникновение коллизий, коглда у нас разные объекты на выходе\
            // могут давать одинаковые значения, такое возможно это нормально, но по возможности этого нужно избегать.

            // При переопределении GetHashCode() лучше всего основываясь на данных возвращать Х, это какой то оператор сравнения, операция
            // позволяет быстро вычислить целочисленный идентификатор определяющий этот объект и определить выполнить первоначальную проверку
            // на равенство. Получается, что перед операциями сравнения целесообразно сначала сравнить их по GetHashCode() методу.
            // Однозначно сказать, что если HashCode у объектов совпадает, то они равны - нельзя, но при этом в обратную сторону, если у нас
            // HashCode разные у объектов, то мы можем однозначно сказать что эти бъекты отличаются между собой.

            // GetHashCode стандартная реализация (создали MyClass для теста тут)
            Console.WriteLine(i.GetHashCode());
            Console.WriteLine(oj.GetHashCode());
            Console.WriteLine(new MyClass().GetHashCode());

            // GetHashCode переопределенная реализация
            Console.WriteLine(p1.GetHashCode());




            Console.WriteLine("||||||ToString() - virtual");
            // Метод ToString() - это приведение к строке. По умолчанию поведение для значимых и ссылочных типов разделяется:
            // поведение для значимых типов - выполняется приведение интового значения к строковом формату.
            // поведение для ссылочных типов - тут нам будет возвращено полное имя типа, класса объекта.
            
            //дефолтная реализация
            Console.WriteLine(i.ToString());    //а так вообще при выводе на консоль ToString и так будет приведен, тут будет 5 как строка
            //переопределенная реализация
            Console.WriteLine(p1.ToString());   //тут будет полное имя пространства имен и имя класса, а если пробрасываем X то приводим
                                                //5 к строке, как в примере выше, тоесть получается работаем с ссылочным типов, а реализация
                                                //как у значимого типа




            Console.WriteLine("||||||GetType() - не virtual, переопределять не можем.");
            // GetType() - с помощью данного метода, мы можем получать тип нужной нам переменной. Данный метод не virtual, а значит мы не
            // можем его переопределить, как это делали с методами выше. Тоесть мы не сможем переопределить получение типа самостоятельно.
            // Как следствие переопределять мы можем только виртуальные методы.
            Console.WriteLine(i.GetType());     //для инта нам вернется тип этой переменной - тут выведется тип переменной
            Console.WriteLine(oj.GetType());    //для упакованной переменной - тут выведется тип переменной, система понимает что это тип int, несмотря на то что они находится в типе object
            Console.WriteLine(p1.GetType());    //для объекта ссылочного типа - тут будет полное имя пространства имен и имя класса
            
            Console.WriteLine("||||||2 похожие синтаксические конструкции, которые позволяют получать тип");
            // Важно понимать, что существует 2 похожиет синтаксические конструкции, которые позволяют получать тип:
            // 1. если мы имеем экземпляр класса и мы хотим узнать тип класса к которому относится конкретно этот экземпляр, то мы
            // используем метод GetType() - тоесть тут мы получает тип из экземпляра класса!
            // 2. если же у нас есть класс и мы хотим получить тип этого класса, тоесть получить переменную, в которой будет храниться не
            // тип экземпляра этого класса, а тип этого класса то мы используем typeof() - тоесть тут мы получает тип из класса!
            Console.WriteLine(p1.GetType());  //используем метод GetType() - получает тип из экземпляра класса!
            Console.WriteLine(typeof(Point)); //используем метод typeof() -  получает тип из класса!
            Console.WriteLine(typeof(Point) == p1.GetType());  //тут равны тк экземпляр из того же класса который мы проверяем на тип.







            Console.WriteLine("||||||2 static метода Object, Equals() и ReferenceEquals(), которые относятся ко всему классу");
            // Статические методы Object:
            // Object.Equals();
            // Object.ReferenceEquals();
            // Принципиальное отличие между ними - когда мы пытаемся сравнить объекты с Equals, то мы пытаемся их сравнить по значению,
            // если мы пытаемся сравнить значения через ReferenceEquals то мы сравниваем объекты по ссылки игнорируя их конкретные значения.
            Console.WriteLine("Equals (static): " + Object.Equals(5, 5));  //тут сравнили по значению и тут true
            Console.WriteLine("ReferenceEquals (static): " + Object.ReferenceEquals(5, 5));//тут сравнили по адресам в памяти и тут false,
                                                                                           //тк это 2 разные переменные в разных участках
                                                                                           //памяти пусть и стека.
            Console.WriteLine("ReferenceEquals (static): " + Object.ReferenceEquals(p2, p2)); //тут сравнили по адресам в памяти и тут true,
                                                                                              //тк они лежат в одном и том же участке памяти.




            Console.WriteLine("||||||protected метод MemberwiseClone()");
            // MemberwiseClone() - позволяет нам создавать дубликаты объектов и он protected, тоесть мы можем использовать его внутри нашего
            // класса, из вне мы не можем создавать клоны нашего объекта.Метод  MemberwiseClone() по умолчание делает не глубокое
            // клонирование и по умолчанию возвращает тип object.
            // Зачем вообще создавать клоны - 
            // Клон - это скопированный объект, который будет содержать все теже поля которые находились в исходном объекте, но это будет
            // отдельный другой объект.

            // Клонирование у нас бывает 2 типов:
            //  - глубокое клонирование
            //  - не глубокое клонрование
            // Их принципиальное отличие - если внутри класса, содержатся значимые типы, они будут продублированы, тоесть у нас будет
            // первый объект и после копирования методом MemberwiseClone(), будет создан второй объект, и во втором объекте будет создана
            // своя собственная переменная "Х". Тоесть переменные "Х" в разных объектах будут находиться в разных участках памяти как и
            // объекты собственно, и между собой ни как не связаны. Но если у нас есть какой то ссылочный тип у объекта, н/п как в классе
            // Point переменная MyClass, то данная переменная тк она ссылочная скопирована не будет, а на нее просто будет указывать 2
            // ссылки с разных объектов, но ссылочная переменная MyClass будет у нас одна. (см. класс Point, там переменные Х и MyClass).
            // И это называетяся не глубокое клонирвоание, когда ссылочный тип не клонируется, а клонируется только значимый тип.
            // И только если мы сделаем глубкое клонирование и только тогда ссылочный тип склонируется. Глубокое клонирование выполняется
            // вручную, мы сами указываем что клонировать, а что нет и так сделано потому что глубокое клонирование выполняется медленно.


            Console.WriteLine("||| Не глубокое клонирование");

            Console.WriteLine("||| проверка значимых типов");
            var pp = new Point() { X = 7 };  // Х-значимый тип
            var pp2 = pp; // если мы сделаем так, то они будут ссылаться на одну и ту же часть памяти, тоесть если мы изменим значение в pp2,
                          // то оно изменится и в pp, тоесть это один и тот же объект с 2 ссылками на него. Так не получится создать клона!
            pp2.X = 77;

            Console.WriteLine(pp.X);    // вывод значимого типа Х (переменные pp и pp2 ссылаются на один объект)
            Console.WriteLine(pp2.X);   // вывод значимого типа Х

            var pp22 = pp.Clone();   // тут мы сделали клона объекта на который ссылается переменная pp
            pp22.X = 88;             // это уже склонированный объект который лежит в другом участке памяти и у склонированного объекта,
                                     // значимый тип, переменная X будет склонирована(тоесть будет своя и лежать в другом участке памяти), а
                                     // ссылочный тип, перменная Y не будет склонирована и останется прежней от первого объекта, от которого
                                     // мы клонировались.
            Console.WriteLine(pp22.X);  // это вывоз значимого типа Х у клона
            Console.WriteLine(pp.X);    // вывод значимого типа Х - проверяем не изменилось ли значение в первом объекте. Не должно тк мы 
            Console.WriteLine(pp2.X);   // изменили его в клоне, а значимый тип Х клона лежит в другом участке памяти.
            // Все верно, вывод 77,77,88,77,77 - у клона значимый тип Х изменился, а в первом объекте значимый тип Х остался прежним.


            
            Console.WriteLine("||| проверка ссылочных типов");
            var ss = new Point() { Y = new Point() };  // Y-ссылочный тип
            var ss2 = ss;
            ss2.Y = new Point() { X = 100 };    // установили значение первичное значение в Y

            Console.WriteLine(ss.Y.X);    // вывод значения "Y" у первого объекта с ссылки ss
            Console.WriteLine(ss2.Y.X);   // вывод значения "Y" у первого объекта с ссылки ss2

            var ss22 = ss2.Clone();     // тут мы вызвали переопределенный метод Clone(), создав клона первого объекта
            ss22.Y.X = 200;             // ss22 это уже склонированный объект который лежит в другом участке памяти и у склонированного
                                        // объекта, переменная "Y" НЕ будет склонирована тк ссылочный тип при не глубоком клонировании
                                        // не клонируется, а ссылка в переменной Y указывает на переменную Y в области памяти первого
                                        // объекта.
            Console.WriteLine(ss22.Y.X);  // это вывод Y у клона(второго объекта), тут мы изменили значение на 200 и теперь это значение
                                          // изменится и у первого объекта от которого мы клонировались, тк это не глубокое клонирование.
            Console.WriteLine(ss.Y.X);    // вывод Y первого объекта с переменной ss
            Console.WriteLine(ss2.Y.X);   // вывод Y первого объекта с переменной ss2

            // Все верно, вывод 100,100,200,200,200 - после того как поменяли значение у клона, оно поменялось и у первого объекта от которого
            // мы клонировались, тк это не глубокое клонирование и переменные ссылочного типа не клонируются, а на них просто появляется
            // дополнительная ссылка из второго объекта на область в памяти в переменную Y в первом объекте.
            





            Console.WriteLine("||| Глубокое клонирование");

            Console.WriteLine("||| проверка значимых типов");
            // примера не привели

            Console.WriteLine("||| проверка ссылочных типов");
            // Если нам нужно глубокое клонирование, то мы это реализуем самостоятельно ручками
            // ДАЛЕЕ в классе Point закоментировал метод Clone() для глубокого клонирования, чтобы не конфликтовал с методом Clone() для
            // не глубокого клонирования
            // примера не привели













        }

    }
}
