using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization.Json;
using System.Xml.Serialization;

namespace CODE_BLOG__26_Сериализация__serialization__объектов_и_работа_с_XML_и_JSON
{
    class Program
    {
        static void Main(string[] args)
        {
            // Сериализация (serialization) объектов и работа с XML и JSON в C# - Учим Шарп #26
            /*
            Сериализация - это процесс преобразования объектов в поток байтов. (определения из книги Рихтера).
            Часто бывает необходимость преобразовать объект в другой формат хранения данных. Тоесть в ООП мы привыкли 
            работать с объктами, тоесть это хранящиеся в памяти структуры, объекты классов, поля, значения, параметры, методы итд мы можем 
            манипулировать этими данными как угодно. Но бывает возникает необходимость когда нужно преобразовать хранящуюся в динамической 
            нашей оперативной памяти структуру, преобразовать во чтото что можно будет положить в постоянную память, записать на диск к 
            примеру, и в дальнейшем чтобы из этого сохраненного файла, можно было восстановить существующую структуру в то же состояние
            как она была во время работы - для этого и нужно Сериализация. Делегаты и события не сериализуются.

            Сериализация - нам позволяет преобразовывать объекты классов в потоковый формат, по сути в какието файлы, в определенном 
            формате, в котором будут сохранены значения всех свойств, всех значений и мы можем это просто положить на жесткий диск или 
            кому то отправить по TCP и на другом ПК восстановить это же объект.

            Сериализация - по сути это просто процесс автоматизации. Мы можем реализовывать сериализацию своими руками, никто нам этого
            не запрещает. Мы можем написать свой метод, который будет перебирать по очереди все свойства и поля класса и записывать это
            в наш собственный формат и сохранять это в файл или передавать это куда либо в виде потока, не принципиально. Тк это часто
            применяемая задача, то были сделаны готовые сервисы, библиотеки, классы, методы для того чтобы делать это быстро, мы просто
            берем и используем готовые подходы и форматы в которых хранятся наши данные они тоже есть стандартизированные их несколько, мы
            сегодня рассмотрим 4 формата: Бинарный, Соуп, XML, Json. В вебе самый часто используемый формат это Json, а XML потихоньку
            сдает позиции. При установки атрибута [Serializable] в:
            Binary - будут сериализованы все поля и свойства приватные и публичные.
            Soap   - будут сериализованы все поля и свойства приватные и публичные.
            XML  - поля и свойства приватные не будут сериализованы, публичные будут.
            Json - нужно отмечать атрибутом [Serializable] каждое поле и свойство которое хочешь сериализовать.

            Резюмируем
            Сериализация - это процесс перевода объекта хранящегося в памяти, какой-то текстовый или близкий к текстовому формату, который
            можно будет сохранять на жесткий диск или передать потоком на другой ПК и далее восстановить.
            Пример:
            У тебя есть в игре авторизованный пользователь и у него есть какие-то значения и после этого он выходит из приложения 
            предварительно сохранившись. Вот по сути процесс сохранения и является сериализацией, когда мы берем текущее состаяние игры, 
            объекты, классы все что там есть, мы это берем и формируем из этого файлик и сохраняем на жесткий диск, а в следующий раз
            когда пользователь приходит мы берем этот файлик, читаем от туда все данные и на основе этих данных мы создаем объекты которые 
            у нас были и пользователь не змечает, что было прерываение после того момента как он уходил. Так же часто в БД пишут 
            сериализованные объекты и сохранения этого состояние, это вполне нормально. 
            */



            // Создаем 2 класса Student, Group
            var groups = new List<Group>();
            var students = new List<Student>();

            for (int i = 1; i < 10; i++)  // создаем генератор групп
            {
                var group = new Group(i, "Группа " + i);
                group.SetPrivate(i);
                groups.Add(group);
            }

            for (int i = 1; i < 10; i++)   // создаем студентов и распределяем их по группам
            {
                Student studen = new Student(Guid.NewGuid().ToString().Substring(0, 5), i % 100)
                {
                    Group = groups[i % 9]
                };
                students.Add(studen);
            }



            
            Console.WriteLine("||||||||| ДАЛЕЕ делаем Сериализацию в формате Binary (Бинарном)");
            // ДАЛЕЕ делаем Сериализацию в формате Binary (Бинарном)
            // Для того чтобы сериализовать класс нам нужно его пометить Атрибутом [Serializable] (пишем над классом). В данном стандартном
            // Бинарном формате Сериализации, будут сериализованы все публичные и приватные поля и свойства.
            // Если мы не хотим что-то сериализовывать в классе, то мы к свойству применяем доп. атрибут [NonSerialized]. Таким атрибутом
            // отметили рандомизатор групп rnd в классе Group - [NonSerialized] private readonly Random rnd = new Random(DateTime.Now.Millisecond);

            // Для сериализации нам нужно работать с каким либо классом который будет этим заниматься, рассматриваем Бинарный сериализатор.
            // Называется он BinaryFormator
            var binFormatter = new BinaryFormatter();   // создали экз. класса

            // далее работаем с потоком и будем сохранять в обычный текстовый файл
            using (var file = new FileStream("groups.bin", FileMode.OpenOrCreate) ) //создаем поток для сохранения в файл
            {
                binFormatter.Serialize(file, groups); //1 параметр принимает наш поток file, 2 параметр это наш объект который мы хотим
                                                      //сериализовать. Теперь группы сериализованы и сохранены в файл groups.bin
            }
            // По сути все, мы взяли готовый BinaryFormatter, который берет на себя всю ответственность за формирование/сериализацию данных
            // и сохранили в файл groups.bin. Но мало сохранить в файл, теперь на нужно как то эти данные восстановить.



            // Делаем восстановление
            using (var file = new FileStream("groups.bin", FileMode.OpenOrCreate)) //создаем поток для восстановление данных из файла
            {
                List<Group> newGroups = binFormatter.Deserialize(file) as List<Group>; //создаем объект newGroups, и ВАЖНО - при
                                                //Десериализации у нас будет возвращаться тип object, что не совсем правильно, поэтому
                                                //нам нужно его привести к тому типу, в котором мы сохраняли, это был тип List<Group>.

                //var newGroups = (List<Group>)binFormatter.Deserialize(file); //это немного другой формат записи на приведение, но разницы
                                                                               //по сути нет, но лучше первый вариат, тк меньше вероятности
                                                                               //что возникнет ошибка и плюс мы всегда можем проверить на null.
                //выводим Десериализованный список
                if(newGroups != null)
                {
                    foreach (Group item in newGroups)
                    {
                        Console.WriteLine(item);
                    }
                }
            }
            





            /*
            Console.WriteLine("||||||||| Сериализация в формате Soap (simple project access protocol)");
            // Сериализация в формате Soap (simple project access protocol)
            // Soap - это соглашение, распространенное общепринятое формирование данных.
            // Soap сериализация очень похожа на Бинарную сериализацию, тк вызовы выглядят один в один, потому что они реализуют один и тот
            // же интерфейс IFormatter. И рекомендуется, если вы захотите писать свой собственный форматор, тоесть собственный механизм
            // сериализации, то желательно, чтобы он наследовался от интерфейса IFormatter.

            SoapFormatter soapFormatter = new SoapFormatter();   //создали экз. класса

            // ДАЛЕЕ делаем Сериализацию в формате Soap  (работаем с потоком и будем сохранять в файл)
            using (var file = new FileStream("groups.soap", FileMode.OpenOrCreate)) //создаем поток для сохранения в файл
            {
                //тк soap строже, он не работает с List<>, поэтому нужно привести к массиву
                soapFormatter.Serialize(file, groups.ToArray()); //1 параметр принимает наш поток file, 2 параметр это наш объект который мы хотим
                                                       //сериализовать. Теперь группы сериализованы и сохранены в файл groups.soap
            }


            // Делаем восстановление
            using (var file = new FileStream("groups.soap", FileMode.OpenOrCreate)) //создаем поток для восстановление данных из файла
            {
                Group[] newGroups = soapFormatter.Deserialize(file) as Group[]; //и тут же приводим формат данных к массиву

                //выводим Десериализованный список
                if (newGroups != null)
                {
                    foreach (Group item in newGroups)
                    {
                        Console.WriteLine(item);
                    }
                }
            }
            // Тоесть мы при Сериализации привели к массиву и при восстановлении данных/Десериализации тоже привели к массиву, тк Soap
            // не работает с List<>, а работает с массивами.
            */





            Console.WriteLine("||||||||| Сериализация в формате XML (simple project access protocol)");
            // Сериализация в формате XML (eXtensible Markup Language - это расширяемый язык разметки).
            // Не реализует интерфейс IFormatter.

            var xmlFormatter = new XmlSerializer(typeof(List<Group>));   //создали экз. класса и он принимает в качестве параметра
                                                                         //тип который мы хотим сериализовать.

            // ДАЛЕЕ делаем Сериализацию (работаем с потоком и будем сохранять в файл)
            using (var file = new FileStream("groups.xml", FileMode.OpenOrCreate)) //создаем поток для сохранения в файл
            {
                xmlFormatter.Serialize(file, groups); //1 параметр принимает наш поток file, 2 параметр это наш объект который
                                                    //мы хотим сериализовать. Теперь группы сериализованы и сохранены в файл groups.soap
            }


            // Делаем восстановление
            using (var file = new FileStream("groups.xml", FileMode.OpenOrCreate)) //создаем поток для восстановление данных из файла
            {
                List<Group> newGroups = xmlFormatter.Deserialize(file) as List<Group>; //и тут же приводим формат данных к массиву

                //выводим Десериализованный список
                if (newGroups != null)
                {
                    foreach (Group item in newGroups)
                    {
                        Console.WriteLine(item);
                    }
                }
            }






            Console.WriteLine("||||||||| Сериализация в формате Json (JavaScript Object Notation)");
            // Сериализация в формате Json (JavaScript Object Notation — текстовый формат обмена данными, основанный на JavaScript.
            // Не реализует интерфейс IFormatter. Тут будем сериализовать не группы а наших студентов. Для Json у нас отдельный атрибут
            // который мы вешаем над классом Student это [DataContract]. Json он лучше xml тк меньше кода и легче читаемый и нет,
            // теговых скобок.

            var jsonFormatter = new DataContractJsonSerializer(typeof(List<Student>));  //создали экз. класса и он как и XML принимает
                                                                                        //в качестве параметра тип который мы хотим сериализовать.

            // ДАЛЕЕ делаем Сериализацию (работаем с потоком и будем сохранять в файл)
            using (var file = new FileStream("students.json", FileMode.Create)) //создаем поток для сохранения в файл
            {
                jsonFormatter.WriteObject(file, students); //1 параметр принимает наш поток file, 2 параметр это наш объект который
                                                    //мы хотим сериализовать. Теперь группы сериализованы и сохранены в файл groups.soap
            }


            // Делаем восстановление
            using (var file = new FileStream("students.json", FileMode.OpenOrCreate)) //создаем поток для восстановление данных из файла
            {
                List<Student> newStudents = jsonFormatter.ReadObject(file) as List<Student>; //

                //выводим Десериализованный список
                if (newStudents != null)
                {
                    foreach (Student item in newStudents)
                    {
                        Console.WriteLine(item);
                    }
                }
            }








            // Таким образом мы получили 4 формата данных которые мы можем сериализовать.
            // Json популярнее в web чем остальные форматы из-за меньшего веса файлов:
            // bin - 1.30 KB
            // soup - soup не смог подключить библиотеку, какое то обновление в Core.
            // xml - 873 bytes 
            // json - 431 bytes 



        }
    }
}
