using System;

namespace CODE_BLOG__3
{
    class Program
    {
        static void Main(string[] args)
        {
            // Переменные C#. Значимые типы и ссылочные типы (value type и reference type) в C# - Учим Шарп #3
            /*
            Переменная - это именнованная область памяти. Переменную нужно явно типизировать тогда когда мы ее не инициализировали.
            так делать нужно  - int a;
            так делать нельзя - var b;


            Есть два типа памяти СТЭК и КУЧА:
            СТЭК(stack) - это грубо говоря быстрая память и объем ее ограничен (8МБ в Linux и 1МБ в Windows). Тут хранится все быстрое.
            Процессор может работать напрямую только со стэком.

            КУЧА(heap) - это память которая ограничена размером ОЗУ в ПК и доступ к ней осуществляется медленнее. Тут хранятся 
            ссылочные данные. Этот тип называется ссылочным, потому, что в СТЭКе хранится только адрес объекта который хранится в КУЧЕ.

            ЗНАЧИМЫЕ типы - это наиболее простые типы. Их несколько видов: 
            Типы значений: (byte, sbyte, short, ushort, int, uint, long, ulong). С плавающей запятой (float, double, decimal, bool, 
            char, перечисления enum, структуры (struct)).

            ССЫЛОЧНЫЕ типы - это типы значений которые хранятся по ссылке, тоесть в переменной в которой вы ее объявляете хранится не 
            значение, а ссылка на область в памяти где хранится значение.
            Ссылочные типы:
            Тип object - это базовый тип для всего в языке С#. В С# все является классами и тип object это базовый прородитель всего. 
                Он очень простой, он позволяет делать ToString, Equal, getHashCode- приводить объект к строке и сравнивать 2 любых 
                объекта между собой.
            Тип string
            Классы (class)
            Интерфейсы (interface)
            Делегаты (delegate)




            Составные типы
            Составной тип данных-это то, что вы можете разделить на несколько других типов. Коробка, которая содержит больше коробок,
            если хотите.
            Теперь рассмотим ситуацию, когда тип значений и ссылочный тип представляют составные типы - структуру и класс:
            private static void Main(string[] args)
            {
                State state1 = new State();       // State - структура, ее данные размещены в стеке
                Country country1 = new Country(); // Country - класс, в стек помещается ссылка на адрес в куче тоесть в переменную country1, 
                                                  // и в куче располагаются все данные объекта country1
            }
            Здесь в методе Main в стеке выделяется память для объекта state1. Далее в стеке создается ссылка для объекта country1 
            (Country country1), а с помощью вызова конструктора с ключевым словом new выделяется место в куче (new Country()). 
            Ссылка в стеке для объекта country1 будет представлять адрес на место в куче, по которому размещен данный объект.
            Таким образом, в стеке окажутся все поля структуры state1 и ссылка на объект country1 в хипе.


            dynamic - это не типизированная переменная, она полностью динамическая. Всегда его избегайте, его не нужно использовать. 
            dynamic был введен в язык только для того, чтобы обеспечить совместимость с не типизированными языками. Беда в том, что
            если мы напишем вычитание строк, а такой операции нет, и если так проделать со стрингами то компилятор заругается, а с 
            dynamic компилятор на вообще ничего не скажет, он снимает с себя ответственность, что хочешь то и пиши.
            dynamic s = "aaa";
            dynamic s2 = "bbb";
            dynamic s3 = s - s2;  - это ошибка компиляции тк строки вычитать нельзя, но при dynamic компилятор снимает с себя 
            ответственность и не ругается. Вывалится рантайм эксептион, в компании за это уволят.


            object может выполнять функции var?
            object - это общее описание любой фигуры геометрической.
            тоесть ты говоришь компилятору вот справа круг, слева определи сам, что это за тип - ТУТ ВСЕ ОК
            а если ты объявляешь object и берешь конкретную фигуру круга и запихиваешь ее в абстрактное понятие фигуры, то ты 
            теряешь все возможности которые есть у круга, остается только то общее которое есть у всех фигур обсалютно. Ты можешь
            обьратно привести в фигшуру круга, но это расход ресурса - ТАК ДЕЛАТЬ НЕ НАДО.


            */

            int i = 5;
            i = 6;
            //i = "asdas"; // так делать нельзя - неявное преобразование

            char c = 'd';   // символьный тип данных, любой один символ







        }
    }
}
