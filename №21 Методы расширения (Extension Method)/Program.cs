using System;
using System.Collections.Generic;

namespace CODE_BLOG__21_Методы_расширения__Extension_Method_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Методы расширения(Extension Method) в C# - Учим Шарп #21
            /*
            Методы расширения - это означает, что мы можем добавлять функциональные возможности в классы, к которым мы не имеем прямого
            доступа и от которых мы не можем унаследоваться, к примеру по причине, что классы могут быть запечатаны sealed, а от 
            запечатанного класса мы не можем создать наследника. Соответственно если нам нужно добавить в запечатанные классы, какие либо 
            методы, расширить функциональность этих классов, то мы напрямую сделать это не можем и ту как раз на помощь к нам приходят
            методы расширения! По сути это синтаксический сахар, позволяет писать меньше кода. 
            
            Методы расширения - может расширять не только классы и структуры, но и интерфейсы ConvertToString(this IEnumerable collection), 
            тогда мы сможем применять наш метод расшир. к любому классу реализующему этот интерфейс.

            Методы расширения - может применяться к самому объекту Road CreateRandomRoad(this Road road, int min, int max), мы обращаемся к
            объекту дороги и этот же объект внутри метода мы меняем. Мы это делали потому что наш класс является запечатанный. Чтобы в 
            каэжой части кода где нам нужно было бы преобразовывать/изменять объект нам бы ни пришлось постоянно писать код как в методе, а
            проще сделать метод расширения и просто его вызывать где нам нужно. 

            Методы расширения для нормальной работы должны:
                - он должен находиться в пределах статического класса
                - метод должен быть статическим
                - метод расширения используем только в том пространстве имен (namespace), где он объявлен.

            Нюанс - hh.IsDevidedBy(20, "name")первый аргумент(hh) передается не явно при обращении к нему через ключ слово this, а второй и 
            третий аргументы являются первым и вторым параметром в методе IsEvenEx(this decimal i, int j, string k). Тоесть "20" пойдет в 
            int j,а строка "name" пойдет в string k.

            Когда нужны методы расширения:
            1. Когда мы работаем с встроенными стандартными типами данных. Н/П: мы не можем унаследоваться от инта Road : Int32, тк это
               структура, а так же Int32 является запечатанным, но какое либо добавить поведение нам нужно.
            2. Когда мы работаем с классом из сторонней библиотеки и в данной ситуации мы не можем изменить доступность класса если он
            запечатан и тут нам помогут методы расширения.


            Важно - не нужно увлекаться с методами расширения, тк это опасно, потому что, мы не контролируем и не можем влиять на тот класс
            который мы расширяем. Тоесть если произошли изменения внутри класса, то мы об этом не узнаем и как следствие наш метод 
            расширения ломается, это оч плохо. Поэтому где возмолжно используем наследование, реализацию интерфейсов или другие паттерны. 
            */




            Console.WriteLine("|||||ДАЛЕЕ проверяем является ли число четным");
            //Console.Write("Insert number: ");
            //string input = Console.ReadLine();
            string input = "6";

            if (int.TryParse(input, out int result))   // проверяем число на корректность, если true то заходим
            {
                //bool isEven = IsEven(result);      // вызов ОБЫЧНОГО метода
                //bool isEven = result.IsEvenEx();   // вызов метода РАСШИРЕНИЯ
                if (result.IsEvenEx()) //но мы можем упростить и вызвать метода РАСШИРЕНИЯ сразу в условии вместо переменной isEven.
                {
                    Console.WriteLine($"{result} - chetnoe chislo.");
                }
                else
                {
                    Console.WriteLine($"{result} - Ne chentnoe chislo.");
                }
            }
            else 
            {
                Console.WriteLine("This is not a number");
            }
            // Выше руками написанный метод с прекрасной логикой, но мы не хотим использовать такой формат записи, мы хотим избавиться
            // от такого вызова bool isEven = IsEven(result); когда мы используем отдельно метод.

            // ДАЛЕЕ - Чтобы этого избежать мы создаем СТАТИЧЕСКИЙ класс Helper и в нем собираем все методы расширения.
            // Для создания методов расширения мы должны использовать статический класс и знать пространство имен где он был объявлен
            // namespace CODE_BLOG__21_Методы_расширения__Extension_Method_ тк методы расширения действуют только в том пространстве
            // имен в котором они объявлены. Если пространство имен у нас будет отличаться, то для того чтобы метод расширения был
            // доступен, нам нужно подключить через using то пространство имен, в котором метод расширения был объявлен.
            // Какая бы ни была у нас переменная типа int, у нее будет доступен этот метод расширения.
            Console.WriteLine("|||||ДАЛЕЕ проверяем является ли число четным");
            int h = 77;
            Console.WriteLine(h.IsEvenEx()); //тоесть в методе расшир. первый this аргумент передается до высова метода h.IsEvenEx(), а
                                             //далее в скобках передается второй аргумент hh.IsDevidedBy(7), н




            Console.WriteLine("|||||ДАЛЕЕ проверяем делится ли число без остатка");
            int hh = 182;
            Console.WriteLine(hh.IsDevidedBy(7));    // тут мы проверяем делится ли число 182 на 7 без остатка
            Console.WriteLine(282.IsDevidedBy(7));   // так тоже можем записать проверку деления без остатка
            //тоесть в методе расшир. первый this аргумент передается до вызова метода hh.IsDevidedBy() или 282.IsDevidedBy(), а далее
            //в скобках передается второй аргумент hh.IsDevidedBy(7).




            Console.WriteLine("|||||ДАЛЕЕ в качестве аргумента мы можем использовать объект road и интерфейс");
            //Создали класс Road, представим что этот класс получен из сторонней библиотеки и мы хотим сделать генератор случайных дорог,
            //тоесть мы делаем метод расширения для класса Road, который будет возвращать нам список дорог на основе уже существующей дороги.

            // создаем несколько дорог
            List<Road> roads = new List<Road>();    // создали лист с дорогами
            for (int i = 0; i < 10; i++)            // создали цикл для быстрого создания 10 дорог и генерации их свойств рандомно.
            {
                var road = new Road();
                road.CreateRandomRoad(1000, 10000);     // в качестве аргумента использовали объект
                                                        // тут мы инициализировали первый аргумент road и передали его в качестве первого
                                                        // аргумента (this Road road, int min, int max) и далее вторым и третим аргументом
                                                        // передаем 1000 и 10 000.
                roads.Add(road);                    
            }

            // и теперь опять обращаемся к нашему другому методу расширения, тк наш список реализуемт интерфейс IEnumerable, мы можем
            // применить наш метод расширения к нему. Тоесть данный метод расшир. мы можем применять к любой коллекции, которая реализует
            // интерфейс IEnumerable, массив, словарь итд.
            var roadsName = roads.ConvertToString();  // в качестве аргумента использовали интерфейс
            Console.WriteLine(roadsName);






        }











        // ОБЫЧНЫЙ метод - проверки, является ли число четным.
        static bool IsEven(int i)
        {
            return i % 2 == 0;
        }





    }
}
