using System;
using System.Collections.Generic;

namespace CODE_BLOG__19__SQL__Entity_Framework_
{
    class Program
    {
        static void Main(string[] args)
        {
            // SQL базы данных и Entity Framework в C# - Учим Шарп #19
            /*
            ORM - это такой подход который позволяет связывать БД и код. Мы можем писать отдельный запрос и создавать что то. Но за нас 
            уже придуманы фреймворки которые могут автоматизировать этот процесс, тоесть мы работаем не с БД, а с классами как мы привыкли.
            Но где то в бекграунде, то зачем мы не следим у нас производится синхронизация между нашими классами, коллекциями классов и 
            тем что хранится в БД, вот Entity Framework берет на себя всю синхронизацию. Мы просто создаем экземпляр класса, и сохраняем его,
            а в БД создается запись в соответствующей таблице со всеми теми данными, которые мы присвоили классу. Нам не нужно напрямую 
            писать запросы в БД, чтото создавать, это все делает Entity Framework, это увеличивает скорость разработки, но имеет 
            недостаток в виде производительности на больших объемах данных, если неправильно писать код.

            // Условно говоря,  у нас будет разделено приложение на 3 части: 
            1. Програмная часть(бизнес логика). 
            2. Виртуальная БД (это закэшированная копия данных, которая является промежуточной между настоящей БД и самим приложением). 
            Чтобы каждый раз при мини изменениях не обращаться к настоящей БД, Entity Framework создает в памяти копию данных и хранит ее 
            и при обращении обращается не к БД, а к закешированным данным. Это снижает нагрузку на сервер, но несет риски рассинхронизации.
            Нужно знать, что ни каждый запрос идет в настоящую БД, тк у нас есть закэшированная копия БД.
            3. Настоящая БД (я так понял)

            // Далее - скачали entity framework, теперь нам нужно создать класс подключения - MyDbContext.
            
            В EntityFramework есть 3 подхода к созданию проекта:
            1. Database first - это значит что у нас есть готовая БД, но мы хотим сделать к ней приложение. Тогда нам не нужно ничего писать
                                ручками, а нужно направить EntityFramework на БД и он нам создаст на основе БД все классы которые есть в БД.
            2. Code first     - это когда мы создаем классы по опред. правилам, указываем как должны выглядеть связи и у нас на основе 
                                написанного нами кода создаются таблицы в БД.
            3. Module first   - это когда ты ни делаешь ни БД ни код, у тебя есть редактор подобный как в MSSQL где рисуешь классы и связи, 
                                нажал кнопку и сгенерировались и классы и БД.

            // Далее нам необходимо создать сущности, создаем класс - Group и Song (это по сути название таблицы, в Entity принято 
            создавать в единственном числе)

            // Далее нам нужно указать коллекции, эти наборы данных которые мы будем использовать. Грубо говоря, все наборы наших таблиц. 
            // Тоесть все те таблицы которые у нас будут реализовываться в EntityFramework.

            */

            // Далее начинаем работать уже с БД. Первое что нужно сделать, это создать context, грубо говоря подключение.
            // У нас подключение к БД автоматически закрывается за счет using блока.
            using (var context = new MyDbContext()) // сделали подключение, параметры не передаем
            {
                Group group = new Group()
                {
                    Name = "Rammstien",
                    Year = 1994
                };
                Group group2 = new Group()
                {
                    Name = "Linkin park",
                };


                context.Groups.Add(group);  // выбираем в какую табюлицу хотим добавить и передаем в качестве аргумента нашу группу
                context.Groups.Add(group2);
                // после этого очень важно понимать, что когда мы добавили группу в context она еще не в настоящей БД, она находится
                // в кэшированном промежуточном хранилище. Соответственно нам нужно дать команду на сохранение. Мы можем набрать коллекцию
                // изменений и сразу всем скопом отправить в БД.

                context.SaveChanges(); // теперь все изменения из локального хранилища утекут в настоящую БД.

                // такой порядок вызовов важен тем, что идентификаторы в БД присваиваются после сохранения изменений, тоесть после строки
                // context.SaveChanges(); 


                // теперь добавляем песни, делаем коллекциями, так правильно.
                List<Song> songs = new List<Song>()
                {
                    new Song() { Name = "In the end", GroupId = group2.Id},
                    new Song() { Name = "Numb", GroupId = group2.Id},
                    new Song() { Name = "Mutter", GroupId = group.Id},
                };

                // теперь нужно сохранить наши песни в БД
                context.Songs.AddRange(songs);
                context.SaveChanges();


                // выведем коллекцию песен
                foreach (var item in songs)
                {
                    Console.WriteLine($"Song name: {item.Name}, Group mame: {item.Group.Name}");
                }

                // делаем запрос, выведим группы
                Console.WriteLine($"id: {group.Id}, name: {group.Name}, year: {group.Year}");

                Console.ReadLine();
            }



            // последнее на сегодня - МИГРАЦИИ - когда мы хотим изменить структуру БД, Н/П: для класса Group добавить поле Type.
            // public string Type { get; set; }    // тут мы добавили в нашем коде НОВОЕ поле в таблицу в БД, тоесть теперь нужно
            // обновить структуру БД. И если мы сейчас запустим приложение мы получим исключение, тк поля в коде и колонки в БД 
            // не синхронизированны.
            // НУЖНО СДЕЛАТЬ СИНХРОНИЗАЦИЮ - при помощи МИГРАЦИЙ, для этого нужно зайти во View - Other windows - Packedge Manager
            // Console - вообще это диспетчер для работы с пакетами NuGet, но тут можно выполнять миграции при помощи Entity Framework.
            // Эта комнда делается один раз для проекта и потом ее повторять не нужно - это разрешение миграции enable-migrations, 
            // данная команда делала не корректную миграцию, тк по идее мы должны вызывать данную команду при создании проекта.
            // В итоге точечно добавили новое поле в миграцию командой add-migration AddGroupType и файл с описанием БД был создан
            // с именем 202109291318056_AddGroupType.Designer. По сути это как коммит в системе миграций, и далее нам нужно ввести
            // команду update-database



        }
    }
}
