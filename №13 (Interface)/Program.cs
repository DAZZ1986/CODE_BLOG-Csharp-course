using System;
using System.Collections.Generic;

namespace CODE_BLOG__13
{
    class Program
    {
        static void Main(string[] args)
        {
            // Интерфейсы C# (Interface) - Учим Шарп #13
            // Интерфейсы - это урезанные определения классов. Интерфейс как и классы создаются в отдельном файле.
            // Интерфейс  - по сути предоставляет нам те методы и свойства, которые будут присутствовать в классе и будут доступны!
            // И при этом он ни как не определяет внутреннюю структуру, как оно будет реализовано, его это не интересует!

            // Интерфейсы - это педали, руль, кпп, тоесть это команды/функционал, которые будут доступны сторонним пользователям
            // для использования.
            // Основной особенностью интерфейса - это то что, он только определяет все эти конструкции, но ни как их не реализует.
            // Тоесть мы говорим, что у микроволновки есть кнопка "Старт", но мы не видим реализации метода внутри и не знаем
            // внутри происходит. Это все что публичное и мы можем использовать модификаторы public и internal.
            // Инерфейсы НЕ НАСЛЕДУЮТСЯ, они реализуются/имплементируются! Множественная реализация интерфейса в С# подерживается.

            // В интерфейсе можно определять:
            // - методы;
            // - свойства;
            // - индексаторы;
            // - события.
            // В интерфейсе мы НЕ можем определять:
            // - поля класса;
            // - мы не можем определять все что закрыто.

            // Зачем нужны интерфейсы:
            // 1. Не задумываемся о реализации, просто определяем как выглядит метод, какие нужны свойства, как мы планируем его
            // задействовать. На этапе проектирования проще продумывать внешний интерфейс, тоесть какие ты видишь способы работы
            // с классом. Если мы архитекторы, то мы разбросали интерфейсы, а реализацию отдаем программистам ниже уровнем.
            // 2. Когда мы хотим чтобы у нескольких классов была конкретная реализация методов из интерфейса, но сама реализация
            // метода может быть коордитнально разная. Н/П: мы можем определить интерфейс IMovement и в нем сделать метод Move() и
            // реализовывать этот интерфейс будет машина, человек, муравей, самолет итд. Тоесть поведение реализаций будут 
            // координально отличаться. И если эти классы реализуют интерфейс IMovement то у этих классов будет гарантированно
            // этот метод Move().

            //Когда мы реализуем интерфейс мы гарантируем, что у экземпляра этого класса будет такой метод. Соответственно мы будем
            //уверены, что, независимо от того, что у нас будет лежать в этом списке, мы спокойно сможем обращаться к методу Move().



            // 1. Банальный пример интерфейсов
            var cars = new List<ICar>(); // тут мы создали лист объектов в который мы можем помещать любые классы которые реализуют 
            cars.Add(new LadaSeven());   // этот интерфейс, но если я в тип листа вставлю интерфейс IDisposable, то мы не сможем 
            cars.Add(new BMWSeven());    // добавить в List класс BMWSeven, тк он попросту не реализует этот интерфейс.

            foreach (var item in cars)
            {
                Console.WriteLine(item.Move(200)); //тут важный момент, мы можем обратиться только к методу Move(), хотя класс
            }                                      //LadaSeven реализует еще интерфейс IDisposable, у него не будет метода Dispose(),
                                                   //тк мы рассматриваем экземпляр этой коллекции только с точки зрения одного
                                                   //интерфейса List<ICar> и как следствие видим только методы интерфейса ICar.


            Console.WriteLine("|||||||||||||||||||||||||||||||||||||||||||");


            // 2. ДАЛЕЕ про ЯВНУЮ и НЕ ЯВНУЮ реализацию интерфейса. (см. класс Cyborg)
            // Явная реализация интерфейса означает, написать имя интерфейса перед именем метода в классе где реализуем интерфейс
            // ICar.Move(), IPerson.Move().
            // создали второй интерфейс IPerson и у этого человека тоже есть метод Move()
            Cyborg cyborg = new Cyborg();
            //cyborg.Move(100);          //тут ошибка, мы не видим у киборга метод Move(), несмотря на то, что он реализует
            ((ICar)cyborg).Move(100);    //2 интерфейса, в таких случаях мы должны привести наш класс к одному из двух интерфейсов.
            ((IPerson)cyborg).Move(100);
            Console.WriteLine($"Преодалел расстояние как киборг за {((ICar)cyborg).Move(100)} час.");
            Console.WriteLine($"Преодалел расстояние как человек за {((IPerson)cyborg).Move(100)} часов.");


            Console.WriteLine("|||||||||||||||||||||||||||||||||||||||||||");


            // 3. ДАЛЕЕ про Последовательное наследование.
            // Создали интерфейс IObject и сделали наследование интерфейса ICar от интерфеса IObject ("ICar : IObject"). Тоесть
            // IObject теперь родитель интерфейса ICar. И далее фишка в том, что если мы унаследовались интерфейс от интерфейса, то
            // далее мы обязаны реализовать все методы интерфейса родителя IObject в том классе где мы унаследовались от интерфейса
            // наследника в нашем случае наследник ICar, а именно в классах LadaSeven, BMWSeven, Cyborg.
            // Тоесть если в любом классе наследуемся от наследника ICar то мы обязаны
            // реализововать методы не только наслединка ICar, но и методы интерфейса его предка IObject.

            // И важный момент - если мы наследуем интерфейс в классе который является родителем, то мы не обязаны реализовывать
            // методы интерфейса наследника! Н/П: в нашем случае унаследовались от интерфейса родителя IObject, в классе Test,
            // то как мы видим там нас не засталяют реализовывать метод Move() интерфейса наследника ICar.










            // Содержание / Очередь создания файлов:
            // 1. Банальный пример интерфейсов - очередь создания файлов: ICar, LadaSeven, BMWSeven - создали интерфейс ICar и
            // реализовали данный интерфейс в классах LadaSeven, BMWSeven.
            // 2. ДАЛЕЕ про ЯВНУЮ и НЕ ЯВНУЮ реализацию интерфейса - создали интерфейс IPerson и класс Cyborg
            // тем самым вв классе Cyborg имплементировали 2 интерфейса ICar, IPerson, а у данных интерфейсов одинаковые имена
            // методов Move() с разной реализацией и для компилятора мы должны явно указать с какого интерфейса брать метод Move()
            // ((ICar)cyborg).Move(100);
            // ((IPerson)cyborg).Move(100);
            // 3. ДАЛЕЕ про Последовательное наследование - создали интерфейс IObject и далее сделали наследование интерфейса от
            // интерфейса ICar : IObject.


        }
    }
}
