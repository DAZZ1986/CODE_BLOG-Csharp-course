using System;

namespace CODE_BLOG__8._2__OOP_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Объектно-ориентированное программирование (ООП) в C#. Инкапсуляция, наследование, полиморфизм #8
            /*
            // 6 ПАРАДИГМ ООП. 
            
            ИНКАПСУЛЯЦИЯ (черный ящик) - это сокрыцтие членов класса внутри класса. В работе это выглядик след. образом -
            мы подаем входные данные, не зная как оно работает внутри и на выходе получаем готовый результат. Именно так должны
            работать классы. Внутренняя структура должна быть закрыта от внешнего взора. Мы должны стремиться к тому, чтобы давать
            доступ только к самому необходимому, все держим внутри и ничего никому не показываем.
            
            public - доступно всем и везде для любого класса.
            internal - открытый в пределах данного проекта.
            protected - доступ только внутри данного класса и его наследников. (по родственным связям)
            private - доступ только конкретно этому классу, не наследникам и никому другому.
            
            
            НАСЛЕДОВАНИЕ - позволяет наследовать методы, свойства идр для класса наследника, это позволяет избегать дублирование кода.
            Н/П: Есть класс Человек и есть класс Доктор, в класс Человек мы поместили все то что есть у доктора, ФИО к примеру и 
            теперь представим что у нас нет наследования и тогда мы вынуждены в классе Доктор объявлять переменные с ФИО, а если у нас
            добавится еще 500 классов Пилот, Нефтяник, Финансист и тд, и в каждом нам придется дублировать код каждому объявляя ФИО.
            

            ПОЛИМОРФИЗМ - это по сути возможность преобразования класса наследника в базовый класс и обратно, это и есть основная идея.
            Н/П: У нас есть базовый класс, и класс наследник, у базового класса есть какие-то свойства и у наследника 
            есть какие-то свойства. Все свойства базового класса всегда будут присутсвовать в наследнике, поэтому если мы наследника 
            преобразуем в базовый класс, то мы откинем все что было у наследника, его свойства итд и у нас останется только то, что 
            есть у базового класса, свойства итд. Тоесть мы выкинем все что было у наследника и оставим только функционал базового
            класса. Тоесть мы из врача делаем человека и он более не имеет все то что у него было от врача. Но если мы сделаем обратное
            преолбразование то данные все восстановятся, тоесть мы данные не удаляем, а просто игнорируем когда приводим к базовому 
            классу. 
            

            АБСТРАКЦИЯ - применять только важное в нашей предметной области, тоесть выбросить все ненужное, тоесть абстрагироваться от
            этого и взять только то что нам будет востребовано в нашей предметной области.
            Н/П: Нам нужно сделать класс человека, что мы можем туда поместить, ФИО, пол, группа крови, тел., место жительства итд, и
            если в каждой системе мы все это будем учитывать, это будет кошмар тк это тысячи параметров, которые нужно заполнять, 
            учитывать итд. Так вот абстрация подразумевает, что мы должны учитывать только те параметры, которые важны в нашей
            предметной области. Если это софт про бухгалтерию, нам не важен его рост, тел., итд. Тоесть берем только нужный нам набор
            параметров.
            

            ПОСЫЛКА СООБЩЕНИЙ - это когда мы можем сделать определенный сигнал, и другой экземпляр класса может подписаться на этот
            сигнал и получать уведомление, как колокольчик на ютубе (оповещение при появлении нового видео). мы можем создавать события
            на эти события могут подписываться другие экземпляры классов, когда что то происходит они получают оповещение и сами 
            решают как реагировать на эти сообщения.


            ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ КОДА - это значит не нужно изобретать велосипед, а использовать существующие конструкции. Формировать
            из своего кода обособленные библиотеки классов которые мы можем переиспользовать.
            */

            // Записи ниже идентичны, верхняя просто которкий вариант без ключа new который выделяет память. Так же создаются
            // экземпляры класса.
            int i = 0;
            Int32 i2 = new Int32();
            i2 = 0;

            Person p1 = new Person();
            p1.firstName = "Vadim";
            p1.lastName = "Frolov";

            Person p2 = new Person();
            p2.firstName = "Ivan";
            p2.lastName = "Ivanov";


            // Наследование
            var d = new Doctor();
            //d.money = 12M;        // тут доступа к переменной money не будет если у переменной будут модификаторы private и
            // protected, потому что класс Program это внешний пользователь, а вот в классе наследнике Doctor
            // доступ к переменной money будет.


            // Полиморфизм
            d.firstName = "Roman";
            d.Specialization = "333";

            Console.WriteLine(d.firstName);
            Console.WriteLine(d.Specialization);   // тут у врача специализация есть.

            Person p = d;       // тут проявляется свойство ПОЛИМОРФИЗМА, тк мы засунули Doctor в Person
            //p.Specialization = "Hirurg";  // и теперь когда мы засунули Doctor в Person ТУТ БУДЕТ ОШИБКА, тк новый объект "p" уже не
                                            // будет обладать тем, чем обладал объект Доктора "d", а именно переменной Specialization!

            // НО данные о том что объект "p" был врачем, они не теряются и мы можем сделать обратное приведение.
            Doctor dd = (Doctor)p;  // восстанавливаем доктора и его данные.
            Console.WriteLine(dd.firstName);
            Console.WriteLine(dd.Specialization);   // специализация снова есть.



        }
    }
}
