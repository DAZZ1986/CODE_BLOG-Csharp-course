using System;
using System.Linq;

namespace CODE_BLOG__25_Атрибуты__Attribute__и_Рефлексия__Reflection_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Атрибуты (Attribute) и Рефлексия (Reflection) .NET в C# - Учим Шарп #25
            /*
            Основное предназначение атрибутов - это возможность получения значений только из определенных параметров, которые отмечены
            нашими атрибутами.

            Мета-данные - это сопутствующие данные, которые не раскрывают нам полезную информацию, содержательную, которая для нас важна.
            Но они нам рассказывают о том как нам читать эти данные, как с ними работать, как их интерпритировать, как вопринимать и что
            это вообще такое. Тоесть это вспомогательные данные которые идут в нагрузку с основной информацией. Они могут быть разного типа.
            Язык C# содержит огромное кол-во мета-данных, которые генерирует сама система .NET, CLR. 
            Но иногда бывают задачи, когда в мета-данные нужно самостоятельно прикрепить какие либо дополнительные мета-данные, которые 
            будут дополнительно передавать какую либо информацию. Для этого и были созданы АТРИБУТЫ - они как дополнительные, нагрузочные,
            описательные данные, которые напрямую не связаны с тем что представленно в классе, либо они служат для лучшей интерпритации для
            того, что находится в классе и позволяют регулировать поведение приложения с помощью доп. атрибутов конструкций.

            Пример: У нас есть набор данных, в котором содержится полезная информация и которую нужно прочитать. Вопрос - как это сделать?
            Вся информация на ПК хранится в двоичном формате, и как правильно интерпритировать этот набор 0 и 1 большой вопрос. Вот как раз
            для этого и были созданы мета-данные. Мало просто передать данные, нужно еще уметь их прочитать.

            Атрибуты - у нас являются наследниками базового класса System.Attribute, соответственно - Атрибут это вспомогательный класс.
            Наименование Атрибута - должен добавляться постфикс Attribute - GeoAttribute.

            Атрибут - это к примеру у тебя есть экз. класса, а к этому экз. класса сверху приклеены еще какие либо данные. Но основная
            особенность работы с атрибутами -это Рефлексия. За счет рефлексии мы можем работать из кода со структурой кода. Тоесть мы можем
            получить наборы параметров методов(их имена), мы можем получить свойства(их имена, их значения). Тоесть это доп. указание
            которые позволяют работать не непосредственно с данными класса, а это доп. данные которые описывают сам класс, саму структуру.
            Не то что внутри экз. класса находится, а то как спроектирован сам класс.
            Так же имя атрибута указываем без постфикса Attribute, а просто Geo и среда разработки поймет о каком атрибуте речь.

            Наши мета-данные будут прикреплены к каждому экземпляру класса, это независимые от конкретного экземпляра данные. 
            Так же мета-данные будут прикреплены к:
            экз. класса, классу, структуре, полю, методу, свойству, делегату, событию, интерфейсу, перечислению, конструктору, ко всей
            сборке.
            */





            Console.WriteLine("||||||| в классе Photo атрибут привяжем ко всему классу");
            // ДАЛЕЕ создаем класс атрибут - GeoAttribute - это наш собственный атрибут, который будет в себе дополнительно содержать гео
            // данные. Тоесть кординаты X, Y где была снята фотография.
            // ДАЛЕЕ создаем класс фотографии - Photo
            // ДАЛЕЕ для того чтобы присоединить наш атрибут(указать доп. мета данные) к классу Photo нам достаточно использовать запись
            // над классом [Geo(10, 20)], в скобках указали те самые наши мета-данные(координаты фото).

            var photo1 = new Photo("hello.png") //атрибут будет прикреплен не к данному конкретному экз.класса photo1, а ко всему классу и всех его экземпляров. 
            {
                Path = @"D:\CODE\C#\repos\old\CODE_BLOG\CODE_BLOG №25 Атрибуты (Attribute) и Рефлексия (Reflection)\bin\Debug\net5.0"  
            };

            var type = typeof(Photo); //получим наш тип класса, тоесть получаем информацию о типе данных нашего класса к которому крепим
                                      //атрибут и после мы можем получить атрибуты этого объекта
            var attributes = type.GetCustomAttributes(false);  // тут мы через метод получаем наши созданные собственные атрибуты, тоесть
                                                               // коллекцию всех атрибутов.
            //и теперь мы можем перебрать нашу коллекцию
            foreach (var item in attributes)
            {
                Console.WriteLine(item);  //тут мы получили наши параметры атрибута, которые являются общими.
            }




            Console.WriteLine("||||||| ДАЛЕЕ в классе Photo атрибут привяжем НЕ ко всему классу, а к свойству Name");
            // ДАЛЕЕ в классе Photo привяжем наш атрибут не ко всему классу, а к свойству Name - основная идея это возможность получения
            // только тех полей, которые у нас отмечены конкретно этим атрибутом.
            // 1. Задача - для начала нам нужно получить наборы свойств/полей
            var properties = type.GetProperties();  //тут нам возвращается коллекция со всеми свойствами класса
            foreach (var item in properties)
            {
                Console.WriteLine(item.PropertyType + " " + item.Name); //получаем тип данных и имена свйоств класса
                var attrs = item.GetCustomAttributes(false); //также мы можем получить атрибуты этих свойств
                foreach (var atr in attrs)
                {
                    Console.WriteLine(atr); //выводим атрибуты этих свойств
                }
            }




            Console.WriteLine("||||||| ДАЛЕЕ мы будем выводить только те свойства которые нам нужны");
            var properties2 = type.GetProperties();  //тут нам возвращается коллекция со всеми свойствами класса

            foreach (var item in properties2)
            {
                var attrs = item.GetCustomAttributes(false); //получаем атрибут

                if (attrs.Any(a => a.GetType() == typeof(GeoAttribute)))  //делаем LINQ запрос и выводим только те свойства у которых есть атрибуты
                {
                    Console.WriteLine(item.PropertyType + " " + item.Name); //получаем тип данных и имена свйоств класса
                }
            }




            Console.WriteLine("||||||| ДАЛЕЕ мы можем накладывать ограничения на наши атрибуты");
            // Это делается с помощью добавления атрибута для атрибута. Используем атрибут [AttributeUsage(AttributeTargets.Method)] над
            // классом GeoAttribute, тем самым накладываем ограничение атрибутом на атрибут. Теперь мы можем использовать наш атрибут Geo
            // только для методов тк в таргете мы указали Method [AttributeUsage(AttributeTargets.Method)]. И если мы попробуем наш
            // GeoAttribute добвить к свойству, как сейчас и есть в классе Photo, мы получаем ошибку. Потому что атрибут GeoAttribute у
            // нас наложен на свойство Name, и как следствие мы получаем ошибку. Чтобы исправить ошибку изменяем ограничение с метода
            // на свойство, тк у нас атрибут наложен на свойство Name и тогда ошибка пропадет - изменяем на
            // [AttributeUsage(AttributeTargets.Property)] и тк у нас есть атрибут над классом Photo закомментируем [Geo(1000, 2000)],
            // чтобы не было ошибки добавим еще один возможный атрибут для использования следующей записью - 
            // [AttributeUsage(AttributeTargets.Property | AttributeTargets.Class)] тоесть добавили возможное приминение атрибута для
            // свойств и классов.







        }
    }
}
