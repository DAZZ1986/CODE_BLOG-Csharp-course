using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace CODE_BLOG__17_async__await__и__thread_
{
    class Program
    {
        static void Main(string[] args)
        {
            /*
            // Асинхронность (async, await) и многопоточность (thread) в C# - Учим Шарп #17

            Создание потока это ресурсоемкая операция, поэтому используем ее когда точно знаем, что она нам нужна. Мы должны знать, 
            какой поток нам нужен, будь то с высоким приоритетом, с измененным именем, не фоновый поток итд. Оператор await мы можем
            использовать только в асинхронных методах, Н/П: static async Task DoWorkAsync().

            4 понятия в данной теме программирования:
            1. Конкурентности - это когда у нас есть 2 и более процесса исполнения, которые могут конкурировать за одни и теже ресурсы, 
            но при этом между собой они не взаимодействуют.

            2. Параллельное исполнение - когда внутри одного приложение мы можем выделить несколько обособленных частей, которые могут
            работать между собой никак НЕ СВЯЗАНО или выполнять какие то действия синхронно и между собой НЕ ВЗАИМОДЕЙСТВУЯ, а в конце
            сойтись и подсчитать какой то общий результат. Тоесть когда внутри одного приложения мы можем встретить не связанные участки
            кода, и не связное парралельное выполнение. 
            Н/П: Вася и Петя капают траншею в разные стороны, они работают парралельно, но при этом они друг с другом не взаимодействуют
            и друг другу не мешают. Они могут начать с разных направление и идти на встречу друг другу и в конце получить объединенный
            результат путем объединения двух разделенных траншей.
            
            3. Многопоточность - это когда есть несколько потоков которые между собой СВЯЗАНЫ и ВЗАИМОДЕЙСТВУЮТ.
            Н/П: У нас есть процессор, для процессора мы можем создать 1 поток основной и допы, эти потоки могут быть связаны между собой.
            При парралельном выполнение потоки между собой не взаимодействуют, при многопоточном программировании у нас может работать
            основной поток и парралельно мы можем создать отдельный поток вычисления или получения данных, и поток вычисления будет
            работать парралельно и в процессе работы между ними может выполняться обновление данных, синхронизация. При многопоточном
            программировании мы ответственны за потоки как программисты, создаем подключение, синхронизируем, закрываем.

            4. Асинхронное программирование - немного отличается по логике от многопоточного программирования. Асинхронность - это когда
            у нас есть уже готовый определенный набор потоков, которые мы можем брать в аренду, скажем так, тоесть взяли поток, вычислили
            что нам нужно и положили его обратно. И эти потоки держатся в приостановленном состоянии на паузе и при необходимости 
            выдергиваются, выпускаются, вычисляют, что нужно и опять встают на паузу. Это на много оптимальнее с точки зрения 
            производительности, но имеет опрелделенные недостатки именно поэтому многопоточность еще существует. В большинстве случаев
            удобнее асинхронность.
            а) При асинхронном программировании основной поток выполняет свою работу без остановки, а доп. поток если встречает функцию
            на вычисление, он останавливает свою работу до завершения вычислений и после завершения идет дальше.
            б) Работа с асинхронными вызовами - для этого используется тредпул так называемый, тоесть операция создания выделения потока
            он ресурсоемкий, на запуск потока уходит много ресурсов, это медленная операция, поэтому эту операцию нужно использовать
            только в тех случаях когда у нас очень долгая параллельная асинхронная операция.
            */


            #region thread
            /*
            // Многопоточность - создаем потоки тред.
            // Это доп. поток без параметров.
            Thread thread = new Thread(new ThreadStart(DoWork0)); //ThreadStart используем когда в методе DoWork НЕТ принимаемых аргументов.
            thread.Start();

            // Это доп. поток с параметром.
            Thread thread2 = new Thread(new ParameterizedThreadStart(DoWork2)); //ParameterizedThreadStart используем когда в методе DoWork2 ЕСТЬ аргументы.
            thread2.Start(int.MaxValue);

            // Это основной поток в методе Main
            int j = 0;
            for (int i = 0; i < int.MaxValue; i++)
            {
                j++;
                if (j % 10000 == 0)
                {
                    Console.WriteLine("Main");
                }
            }
            // И у нас в консоли одновременный вывод с 3 потоков DoWork2, DoWork, Main, кто успел перехватить вывод тот и вывел.
            */
            #endregion


            #region async/await
            /*
            // Самый частоиспользуемый поток - это у нас реализация асинхронности с помощью ключевых слов (async, await). Эти два ключвых
            // слова по сути упрощают работу с асинхронными делегатами. Мы их не будем сегодня рассматривать, тк считается устаревшими.
            // Главное понимать, что это просто обертка над callback функции асинхронных делегатов.

            // Task - это специальный класс для того чтобы метод у нас мог использоваться как асинхронный, он должен возвращатьл либо тип
            // Task либо Task<T> либо void.
            // СИГНАТУРА: ключевое_слово тип имя_метода = async Task MyName();
            // По внегласному правилу, все асинхронные методы именуем с добавлением ключевого слова Async - DoWorkAsync(). Если мы видим
            // в имени метода Async - значит этот метод может быть вызван асинхронно.

            
            // До вызова асинхронного метода начинаем
            Console.WriteLine("Begin main");
            // Вызываем наш асинхронный метод синхронно.
            DoWorkAsync(10); //от метода Main идет основной поток, после того как основной поток дошел до метода DoWorkAsync(), и в методе
                             //вызывается дополнительный поток, а основной поток идет далее по методу Main().

            Console.WriteLine("Continue Main");

            // Это основной поток в методе Main
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("Main");
            }
            Console.WriteLine("End Main");
            */
            #endregion


            #region Test App
            /*
            // Представим себе приложение для сохрание в файл большого набора данных и мы не хотим чтобы форма грузилась, поэтому делаем
            // асинхронно. Соответственно как мы делаем это синхронно - мы пишем метод.
            
            // ЭТО СИНХРОННОЕ ИСПОЛНЕНИЕ, когда консоль будет висеть тк основной поток будет заблокирован.
            // Представим себе приложение для сохрание в файл большого набора данных и мы не хотим чтобы форма грузилась, поэтому делаем
            // асинхронно. Соответственно как мы делаем это синхронно - мы пишем метод.
            var result = SaveFile("Text.txt"); // запуская метод, у нас блокируется главный поток, пока вычисляется строка, пока
                                               // записывается файл и после этого в конце нам выдается результат.
            var input = Console.ReadLine();    // тут мы, как открывается консоль пытаемся что то печатать, но текст не появляется, тк
                                               // управление перехвачено и консоль грузится/ждет пока запишется файл и потом весь текст вываливается.
            Console.WriteLine(result);         
            */

            // ЭТО АСИНХРОННОЕ ИСПОЛНЕНИЕ, когда консоль будет НЕ висеть тк основной поток НЕ будет заблокирован.
            var result2 = SaveFileAsync("Text2.txt"); // запуская метод, у нас НЕ блокируется главный поток
            var input2 = Console.ReadLine();          // и в консоли должно печататься сразу
            Console.WriteLine(result2.Result);   // тут мы получили результат результата, тк этот метод SaveFileAsync у нас возвращает
                                                 // не просто bool, а Task<bool>.
            Console.ReadLine();
            #endregion




            #region locker
            // Не приятные ситуации в асинхронном программировании:
            // а) Толкатся - Н/П: представим нам нужно выкопать яму и если операция маленькая, нет смысла распаралеливать поток делая его
            // АСИНХРОННЫМ, тк он будет выполняться дольше чем СИНХРОННЫЙ. Так как по ресурсам это будет равносильно если туда загнать 50
            // человек и все будут толкаться за территорию. Поэтому в асинхронном программировании не нужно делать как можно больше потоков.
            // б) что может быть еще хуже того как потоки будут пинать друг друга локтями - когда несколько потоков могут попытаться
            // обратиться к одним и тем же ресурсам, к примеру к перименной и они могут попытаться ее изменить и это самое страшное,
            // потому что мы не может быть уверены что там будет то что мы туда положили.
            // в) так же ужас если два потока захотят писать в один и тот же участок памяти одновременно. Это могут быть 2 массива данных,
            // которые начнуть писаться в один участок памяти или 2 файла записываются в один и тот же участок памяти.
            // г) Deadlock - это такая ситуация когда 2 потока начинают зависеть друг от друга, от значений друг друга и к примеру методы/
            // потоки дергают это значение то туда то суда и не факт что кто то переборит, а зачастую все блокируется встает и не работет.

            // Ссылочные типы хранятся в куче(строки, массивы), а значимые типы в стеке(инты, структуры).
            // К примеру, значимые типы и ссылочные типы, когда передаются в метод, то у значимых типов в методе создается их копия,
            // а ссылочные типы в метод передаются по ссылке(область памяти в куче) и тут как раз каждый поток туже самую строку сможет
            // менять асинхронно. А целое значение он менять не сможет тк для каждого оно будет свое.
            // Н/П: я положил в ящик 100р, пришел вася взял мои 100р и положил 10р, я вернулся и расстроился, так и делают потоки, тк у
            // нас одно общее хранилище куда записываются данные несколькими потоками и там может быть полная несуразица между потоками,
            // кто что записал, что откуда пришло непонятно, это нужно избегать - ЭТО МЫ ГОВОРИМ ПРО ЗАПИСЬ. А чтение из глобальных 
            // перименных не запрещено, тоесть любой поток может брать и читать одну и ту же переменную сколько угодно раз.

            // КАК этого всего избегать - очень просто, при помощи специальных методов, способов синхронизации.
            // Соответственно, если мы хотим сделать какой то участок кода доступным только для 1 потока - тоесть 1 поток начал свое
            // выполнение и до тех пор пока этот поток не закончит свое выполнение другой не мог получить доступ к этому участку кода.
            // Это делается просто, для этого создается объект синхронизации (ниже создал объект locker) и чтобы какой либо участок
            // защитить, нам достаточно этот участок кода просто обернуть с помощью команды lock. Защитили часть кода в методе 
            // SaveFile(string path). Локер обязательно должен быть ссылочным типом, потому, что для каждого потока у нас может valuetype
            // создаться свой, а ссылочный он будет общий для всех. Тоесть в методе может локер отдублироваться если будет значимым типов, 
            // а ссылочный он будет общий для всех.
            #endregion

        }





        #region locker
        public static object locker = new object(); //создали объект синхронизации locker и ниже просто обернули участок кода в команду lock.
        #endregion





        #region Test App и locker
        // ТЕПЕРЬ МЫ ДЕЛАЕМ АСИНХРОННО - делаем асинхронную обертку для метода SaveFile()
        static async Task<bool> SaveFileAsync(string path)
        {
            var result = await Task<bool>.Run(() => SaveFile(path));// тут мы ожидаем результат выполнения метода  SaveFile() и после
                                                                    // возвращаем результат в Main, но при этом основной поток в Main
                                                                    // не блокируется и консоль у нас должна работать.
            return result;
        }


        // СЕЙЧАС ЭТО СДЕЛАНО СИНХРОННО
        static bool SaveFile(string path)
        {
        lock (locker)   // командой lock - заблокировали участок кода, чтобы к данному участку кода одновременно мог
                        // обратиться только 1 поток и после его завершения только потом мог обратиться следующий поток.
            {
            var rnd = new Random();
            string text = "";
            for (int i = 0; i < 40000; i++)
            {
                text += rnd.Next();
            }
        }
            using (var sw = new StreamWriter(path, false, Encoding.UTF8))
            {
                sw.WriteLine();
            }

            return true;
        }
        #endregion





        #region async/await
        // Task - делаем асинхронный метод абертку DoWorkAsync над методом DoWork3. После ключа await мы делаем вызов метода Task.Run(() => DoWork3());
        static async Task DoWorkAsync(int num)
        {
            Console.WriteLine("Begin async");
            await Task.Run(() => DoWork3(num));//команда await говорит о том что нужно ждать завершения выполнения этой задачи Task.Run(() => DoWork3());  
            Console.WriteLine("End async");    
        }
        static void DoWork3(int num)
        {
            for (int i = 0; i < num; i++)
            {
                Console.WriteLine("DoWork async");
            }
        }
        #endregion





        #region thread
        // Многопоточность - создаем методы для перидачи в потоки.
        static void DoWork0()
        {
            for (int i = 0; i < 10000; i++)
            {
                Console.WriteLine("DoWork 0");
            }
        }
        static void DoWork2(object max)
        {
            int j = 0;
            for (int i = 0; i < (int)max; i++)
            {
                j++;
                if (j % 10000 == 0)
                {
                    Console.WriteLine("DoWork 2");
                }
            }
        }

        #endregion




    }
}
