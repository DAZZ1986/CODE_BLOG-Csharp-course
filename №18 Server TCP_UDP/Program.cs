using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace _18_ServerTcp
{
    class Program
    {
        static void Main(string[] args)
        {
            #region TCP 
            /*
            // Чтобы установить взаимодействие нам нужен конкретный адрес приложения в сети. Адрес в сети задается 2 параметрами - это IP
            // и порт.
            const string ip = "127.0.0.1";
            const int port = 8080;

            // Теперь нужно объявить экземпляр класса endpoint - это конечная точка, тоесть то место куда можно подключаться. У одного
            // сервера может быть несколько endpointов разного вида и к ним смогут подключаться по разным адресам. Это по сути точка
            // подключения.
            var tcpEndPoint = new IPEndPoint(IPAddress.Parse(ip), port);// принимает в качестве аргумента IP адрес либо в формате лонг,
                                                                        // либо в формате специального ip адреса.

            // Теперь нужно создать сокет - это дырочка, дверка, через которую можно заходить и будет устанавливаться соединение.
            var tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); // тут задаем набор параметров
                                        // сокета для TCP протокола. Это IP адрес 4 версии, потоковая передача данных для TCP протокола.

            // Теперь нужно выполнить связывание, тоесть перевести наш сокет в режим ожидания. Указать сокету, какой конкретный порт ему
            // нужно слушать.
            tcpSocket.Bind(tcpEndPoint);  // команда Bind делает связывание сокета с endpointОМ, который мы создали, положив в переменную
                                          // tcpEndPoint координаты для подключения. Тоесть сказали сокету где он должен слушать.

            // Теперь мы должны запустить наш сокет на прослушивание.
            tcpSocket.Listen(5); //в аргументе мы можем задать очередь подключений клиентов. первый пришел установил соединение, если в
                                 //этот момент пришел второй, то он становится в очередь итд. Если придет 6 то его отправят гулять.

            // Теперь нам нужно сделать процесс прослушивания, он должен быть бесконечным.
            while (true)
            {
                var listener = tcpSocket.Accept(); // тут создали обработчик на прием сообщения, тоесть еще одного слушателя, некий
                                                   // подсокет, в котором будет выполняться обрабатывание этого конкретного клиента.
                                                   //Тоесть этот подсокет создается под каждого отдельного клиента и после он уничтожается.
                                                   // Клиент пришел, создали listener данные обработали, отправили ответ, клиент ушел,
                                                   // уничтожили его и далее создаем для нового клиента.

                var buffer = new byte[256];        // теперь нам нужен буфер, то место куда мы будем принимать наше сообщение/данные.
                                                   // это та переменная куда будут приходить данные, между сокетами пересылается в
                                                   // двоичном формате, поэтому нам нужно кудато эти данные получать. Хранилище данных.

                var size = 0; // это переменная в которую будет сохраняться кол-во реально полученных байтов. Тоесть мы задали размер
                              // буфера максимум из 256 байт, но из всего этого массива сообщение может быть короче и кол-во байт будет
                              // занято меньше, поэтому создаем эту переменную для записи кол-ва реально полученных байт.

                var data = new StringBuilder(); // это билдер который будет наши данные собирать

                // теперь нам нужно получать наше сообщение.
                do 
                {
                    size = listener.Receive(buffer); //в size у нас запишется реально полученных байт из этого сообщения и далее нужно сохранить
                    data.Append(Encoding.UTF8.GetString(buffer, 0, size));  // тут мы будем добавлять данные, дописывать. Данные передаются
                    // в кодированном формате, мы используем общую кодировку UTF8. Тут мы кусками по 256 байт берем, перекодируем,
                    // добавляем в строку, и снова берем, перекодируем, добавляем в строку итд и так собираем все целиком сообщение.
                } 
                while (listener.Available > 0); // тут нам нужно проверять условие что мы получили запрос

                // и после этого в data у нас собирается все сообщение
                Console.WriteLine(data);    // TODO: check for .ToString()

                // и даем ответ
                listener.Send(Encoding.UTF8.GetBytes("Success."));

                // закрываем наше подключение, нашего listener
                listener.Shutdown(SocketShutdown.Both); // сначала выключили его
                listener.Close();                       // и тут после выключения закрываем
            }
            */
            #endregion



            #region UDP
            /*
            // у TCP происходило общение 2 человек, а у UDP мы можем сделать подключение большого кол-ва клиентов, тоесть все будут
            // подключаться к чату и каждый сможет получать и отправлять сообщения.

            const string ip = "127.0.0.1";
            const int port = 8081;

            var udpEndPoint = new IPEndPoint(IPAddress.Parse(ip), port);    // место куда подключаемся

            var udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp); // тут немного другие параметры,
                                                                                                        // для UDP тип Dgram.
            // теперь делаем подключение связывание
            udpSocket.Bind(udpEndPoint);  // команда Bind делает связывание сокета с endpointОМ, который мы создали, положив в переменную
                                          // tcpEndPoint координаты для подключения. Тоесть сказали сокету где он должен слушать.


            while (true) // все это положили в while (true) для того чтобы получать не одно сообщение, а много.
            {

                var buffer = new byte[256];  // теперь нам нужен буфер, то место куда мы будем принимать наше сообщение/данные.
                                             // это та переменная куда будут приходить данные, между сокетами пересылается в
                                             // двоичном формате, поэтому нам нужно кудато эти данные получать. Хранилище данных.

                var size = 0; // это переменная в которую будет сохраняться кол-во реально полученных байтов. Тоесть мы задали размер
                              // буфера максимум из 256 байт, но из всего этого массива сообщение может быть короче и кол-во байт будет
                              // занято меньше, поэтому создаем эту переменную для записи кол-ва реально полученных байт.

                var data = new StringBuilder(); // это билдер который будет наши данные собирать
                
                // теперь делаем прослушивание
                EndPoint senderEndPoint = new IPEndPoint(IPAddress.Any, 0);// сюда будет сохранен адрес клиента.
                                                                           // создали экземпляр листнера,  у нас нету подключения точка-точка,
                                                                           // как было с TCP. Нам необходимо сохранить куда то адрес подключения.
                                                                           // и соответственно мы его прослушиваем
                do
                {
                    size = udpSocket.ReceiveFrom(buffer, ref senderEndPoint);

                    // продолжаем получать данные через наш StringBuilder
                    data.Append(Encoding.UTF8.GetString(buffer));
                } while (udpSocket.Available > 0);

                // отправляем сообщение о успешности получении
                udpSocket.SendTo(Encoding.UTF8.GetBytes("Messege recived"), senderEndPoint);

                // теперь нужно закрыть подключение


                // теперь нужно вывести полученное сообщение
                Console.WriteLine(data);
            }


            // TODO: закрытие сокета
            */
            #endregion
        }
    }
}
