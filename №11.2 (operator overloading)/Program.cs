using System;

namespace CODE_BLOG__11._2__operator_overloading_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Перегрузка операторов (operator), абстрактные классы, static в C# - Учим Шарп #11

            // abstract - это ключевое слово делает классы абстрактными, которое запрещает делать экземпляры данного класса.
            // Абстрактные классы нужны для того, чтобы сделать общий функционал для нескольких классов, чтобы не дублировать код.
            // Product a = new Product(); // тут ошибка тк мы не можем создавать экзепляры абстрактного класса, тк это не
            // конкретное что то, это все то что будет общее для всех продуктов.

            // 1. Он нужен для того, чтобы делать иерархию наследования, мы в абстрактном классе определяем группу родственных
            // объектов (это все то что будет общее для всех продуктов, НП: для яблока, гречки итд.)
            // 2. Абстрактные классы мы создаем для каких либо не конкретных понятий. Это просто как группировка различных объектов, 
            // которая позволяет уменьшить дублирование кода.
            // 3. Абстрактный класс будет являться фигурой, а конкретный класс будет являться кругом, квадратом, прямоугольником итд.
            // В нашем случае абстрактным классом будет продукт, а конкретными классами будут, крупа, гречка, яблоко итд. Тоесть мы
            // не можем создать абстрактный продукт, но на основе абстрактного продукта, существуют конкретные продукты.
            // Каждый продукт будет обладать какими то общими свойствами, которые мы и пропишем в абстрактном классе.

            Apple apple1 = new Apple("Красное яблоко", 100, 100);
            Apple apple2 = new Apple("Зеленое яблоко", 90, 110);

            // метод Add() мы вызвали ни через экземпляр класса, а через имя класса, потому что метод Add() является статическим.
            Apple sumApple = Apple.Add(apple1, apple2);  // тоесть это как статический класс у которого не может быть своих
                                                         // объектов/экземпляров класса.

            Apple sumApple2 = apple1 + apple2;     // тут делаем сложение через переопределенный знак "+" в методе "operator +".
            Apple sumApple3 = apple1 + 100;        // всегда возвращается новый экземпляр

            Console.WriteLine($"apple1: {apple1}");
            Console.WriteLine($"apple2: {apple2}");
            Console.WriteLine($"sumApple: {sumApple}");
            Console.WriteLine($"sumApple2: {sumApple2}");
            Console.WriteLine($"sumApple3: {sumApple3}");

            // проверяем на оператор сравнения
            Console.WriteLine($"apple1 == apple2: {apple1 == apple2}");            // false - тк имена разные
            Console.WriteLine($"sumApple == sumApple2: {sumApple == sumApple2}");  // true  - тк имена одинаковые
                                                    // Если мы удалим наши переопределенные методы сравнения, то тк это два объекта,
                                                    // компилятор будет сравнивать адреса этих объектов в памяти, и тк это разные
                                                    // объекты, тут будет false тк адреса разные. Тоесть мы не имена будем сравнивать,
                                                    // или другие параметры, а адреса объектов.



        }
    }
}
