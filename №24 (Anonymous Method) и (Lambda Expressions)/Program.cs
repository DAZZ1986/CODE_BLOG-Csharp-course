using System;
using System.Collections.Generic;
using System.Linq;

namespace CODE_BLOG__24__Anonymous_Method__и__Lambda_Expressions_
{
    class Program
    {
        public delegate int MyHandler(int i); // создали делегат анонимного метода


        static void Main(string[] args)
        {
            // Анонимные методы (Anonymous Method) и лямбда-выражения (Lambda Expressions) в C# - Учим Шарп #24
            /*
            Анонимные методы - это это определенный набор инструкций, так же как и в обычном методе, но особенность в том, что ему не дано
            отдельное имя. Его нельзя вызвать отдельно от его контейнера, а контейнер для анонимного метода является делегатом. Тоесть 
            мы как в обычном методе можем передавать параметры, организовывать процесс обработки, возвращать значение, но нет имени и мы 
            не можем вызвать метод отдельно! CODE_BLOG писал статью, что не стоит бояться выделять отдельные методы и методы должны быть
            короткими, тк ты понимаешь из названия, что этьо за метод и что, он делает. Код более понятен по названию метода. Но если это 
            анонимный метод, у тебя нет подсказки в виде имени, и тебе нужно вникать в его функционал, чтобы понять что он делает. 
            Но в некоторых случаях анонимные методы писать можно, для того чтобы динамически менять поведение метода!! Особенно их 
            продвинутая версия - это лямбда выражения. CODE_BLOG использует анонимные лимбда выражения в единственном месте - это линк! Так
            же в некоторых случаях пишет короткий обработчик выражения. 


            СИНТАКСИС анониманого метода:
            delegate (тип_аргумента аргумент1, аргумент2, итд)  // если аргументов нет, то круглые скобки можно не указывать
            {
                реализация метода;
            };
            Сам по себе анонимный метод существовать не может, он может быть только как инициализатор для делегата. Тоесть предварительно
            нам нужно в верхней части класса создать делегат - delegate void MyHandler(int i); //делегат анонимного метода. Далее у нас
            естественно должна совпадать сигнатура делегата с сигнатурой анонимного метода, тоесть СИГНАТУРА:
             - наличие возвращающего значения
             - типы аргументов
             - кол-во аргументов




            Лямбда-выражения - это по своей сути анонимные методы на максималках. Они дают более лаконичный и короткий код, но служат для 
            той же самой цели. Основной плюс лямбда-выращений - они позволяют динамически менять тип, тк мы его не указывали 
            "MyHandler lambdaHandler = (i) =>" (параметр i без типа). А тип будет получен из делегата delegate int MyHandler(int i);.

            СИНТАКСИС лямбда-выражения:
            MyHandler lambdaHandler = (i) => i * i; // тк логика в одну строку, можно без фингурных скобок.

            MyHandler lambdaHandler = (i) =>    // пишем имя делегата, далее даем имя обработчику события, далее  в скобках мы
                                                // указываем только имена параметров без указания их типа, а тип будет браться с
                                                // делегата, далее указывается лямбда оператор =>, далее если несколько строк кода в
                                                // теле, то мы указываем фигурные скобки, если одна инструкция то фигурные скобки не 
                                                // обязательны.
            {
                var r = i * i;
                Console.WriteLine(r);
                return r;
            };
            lambdaHandler(result2);    // тут передаем в хендлер значение от пользователя
            */








            Console.WriteLine("|||||||| Анонимные делегаты");

            if (int.TryParse(Console.ReadLine(), out int result))   // делаем ввод с консоли
            {
                // в наш делегат мы помещаем наш анонимный метод
                MyHandler handler = delegate (int i)    // handler это обработчик событий
                {
                    var r = i * i;
                    Console.WriteLine(r);
                    return r;
                };
                handler += Method; // чтобы нам поместить в наш делегат еще один метод, то мы это делаем присвоив наш обработчик событий
                handler(result);    // тут передаем в хендлер значение от пользователя
                handler(88);        // тут мы просто руками передали аргумент в методы делегата, тк в делегате 2 метода, они отработали 
            }

            // Method(88);
            // Делаем вывод на консоль и если вводим 7, то на выход, 49, 343. Тоесть мы в наш делегат поместили как анонимный метод, так 
            // и не анонимный метод. Тоесть неважно какой метод помещать в делегат и вызывать его потмо из делегата. И вызвали мы их по
            // степени добавления в делегат. Но если мы не анонимный метод можем вызвать по имени нде нам это будет нужно н/п Method(88),
            // то к анонимному методу, мы можем обращаться только через делегат.









            Console.WriteLine("||||||||ДАЛЕЕ Лямбда-выражения");

            if (int.TryParse(Console.ReadLine(), out int result0))   // делаем ввод с консоли
            {                                    // Синтаксис:
                MyHandler lambdaHandler = (i) => // пишем имя делегата, далее даем имя обработчику события, далее в скобках мы указываем
                                                 // только имена параметров без указания их типа, а тип будет браться с делегата, далее
                                                 // указывается лямбда оператор =>, далее если несколько строк кода в теле, то мы
                                                 // указываем фигурные скобки, если одна инструкция то фигурные скобки не обязательны.
                {
                    var r = i * i;
                    Console.WriteLine(r);
                    return r;
                };
                lambdaHandler(result0);    // тут вызываем наш лямбда отбработчик, предварительно передав в него значение от пользователя
            }








            Console.WriteLine("|||||||| ДАЛЕЕ реальные примеры для лямбда-выражения");
            Console.WriteLine("|||||||| Пример 1 для лямбда-выражения");
            // ДАЛЕЕ создаем класс Lesson, в котором есть событие и мы хотим сделать обработчик данного события с помощью
            // лямбда-выражения. Мы не хотим писать нормальный обработчик тк лень, а просто хотим при помощи лямбда-выражения. Обработка
            // будет встречаться всего один раз, поэтому выделять отдельный метод лень. 

            var lesson = new Lesson("Программирование на С#");
            lesson.Started += (sender, date) =>   // подписались на событие и сразу сделали его обработчик
            {
                Console.WriteLine(sender);
                Console.WriteLine(date);
            };  // заметка - в конце точка с запятой ставится в конце анонимного метода и лямбда-выражения

            //добавим процесс начала урока
            lesson.Start();




            Console.WriteLine("|||||||| Пример 2 из линка для лямбда-выражения");
            var list = new List<int>();
            for (int i = 0; i < 10; i++)
            {
                list.Add(i);
            }
            var res = list.Aggregate((x,y)=> x + y); //наша агрегатная функция будет брать по очереди все элементы коллекции, присуммировала
                                                     //второе число к первому, потом третье число к первому и тд по всем числам.
            Console.WriteLine(res);




            Console.WriteLine("|||||||| Пример 3 с динамическим изменением для лямбда-выражения");
            Console.WriteLine("пример 3.1");
            // 1. тут мы вызываем метод Arg, в параметре которого передаем делегат(делегат - это наш анонимный метод) и перед тем как
            // выполнится суммирование, у нас будет вызван наш анонимный метод.
            var result1 = Agr(list, delegate (int i)    // первый параметр это лист, второй параметр это делегат/анонимный метод
            {
                var r = i * i;
                Console.WriteLine(r);
                return r;
            });

            Console.WriteLine("пример 3.2");
            // 2. точно так же мы можем передать и метод с именем
            var result2 = Agr(list, Method);    // первый параметр это лист, второй параметр это метод

            Console.WriteLine("пример 3.3");
            // 3. мы можем передать с помощью лямбда-выражения
            var result3 = Agr(list, x=> x * x * x * x);    // первый параметр это лист, второй параметр это лямбда-выражения

            // Основная прелесть делегатов, анонимных методов и лямбда-выражений - мы можем очень коротко записывать и менять поведение
            // одного метода, передавая в него, внутрь другую логику. Лямбда-выражения позволяют эту логику записывать более компактно.
            // Аноимные методы используем с осторожностью, тк могут сделать код хоть и проще но не читаемым!


        }








        // мы так же можем реализовать обычный метод и положить в тот же делегат
        public static int Method(int i)
        {
            var r = i * i * i;
            Console.WriteLine(r);
            return r;
        }


        // Пример 3 с динамическим изменением
        public static int Agr(List<int> list, MyHandler handler) // первый параметр это лист, второй параметр это делегат
        {
            int result = 0;
            foreach (var item in list)
            {
                result += handler(item);
            }
            return result;
        }



    }
}
