using System.Collections;
using System.Collections.Generic;

namespace CODE_BLOG__12
{
    public class Eating<T, TT>
        where T: Product       // тут задаем ограничение на передаваемый тип данных, тк суда мы можем ни дай бог передать int и
        where TT: IEnumerable  // система ругаться не будет, тк мы используем универсальный тип данных <T>, а данная строка
// "where T: Product" позволяет нам указать базовый тип. Теперь суда можно передать только тип <T>, который может быть только
// Product или любого его класса наследника. Если у нас несколько параметров, НП: <T, TT> то у нас может быть несколько where.
// Так же можем передавать интерфесы и все классы реализующие этот интерфейс.
// Так же можем передавать структуру(она хранится в стеке и имеет не все возможности класса, но при этом имеет свои преимущества).
// Так же можем передавать ключевое слово "class" - это говорит о том что тип обязательно должен быть классом.
// Так же можем передавать ключевое слово "new()" - это означает что у класса должен быть публичный конструктор без параметров.
    {


        public int Volume { get; private set; }



        public void Add(T product)  // тут обобщенный тип может быть не только void, но и возвращаться "T"
        {
            Volume += product.Volume * product.Energy;
        }



    }






}
