using System;

namespace CODE_BLOG__28_Сборка_мусора__Garbage_Collection__GC_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Сборка мусора (Garbage Collection, GC) .NET в C# - Учим Шарп #28
            /*
            Типы переменных в C#:
            Значимый тип (ValueType) - при передачи в метод переменной данного типа, происходит его копирование. Тоесть осле обработки 
            методом данной переменной, вне метода данная переменная останется без изменений, тк в метод попала копия.

            Ссылочный тип (Reference type) - при передачи в метод переменной данного типа, НЕ происходит копирования, тк в переменной лежит
            не значение/объект, а ссылка(адрес) на область в памяти со значением/объектом и соответственно мы эту ссылку передаем в метод 
            и тут уже если мы в методе что либо сделаем с этим объектом то мы напрямую его изменим.

            
            Типы памяти:
            Управляемая - это та с которой у нас работает приложение через CLR. О управляемой памяти заботиться не нужно, с ней работает GC.
            Не управляемая - это та память где мы сами должны следить за выделением и освобождением памяти.

            Типы памяти:
            Stack (стэк) - ограничен по размеру(6 mb), но он быстрее. (ValueType: int, char, bool, struct). 
            Как работает Stack - это определенный участок в памяти, ограниченный, в котором есть ячейки памяти. У каждой ячейки памяти 
            есть физический адрес, и когда мы задаем int a = 7; то в памяти мы даем имя участку памяти "a", и в дальнейшем мы можем 
            обращаться к этому участку памяти по имени. Это упорядоченная область памяти тк у нас постоянно есть указатель на следующий 
            участок свободной ячейки в памяти.

            Heap (куча) - это вся память ОЗУ, но она работает медленнее. (Reference type: string, class). Тут храним большие типы данных.
            Как работает Heap - это НЕ упорядоченная область памяти тк это просто большая область в памяти, куда мы можем помещать какие 
            либо данные. Если мы создадим класс "C" с одной переменной int Value {get; set;}, так вот, когда мы создаем экземпляр этого =>
            class C
            {
                int Value {get; set;}
            }
            => класса с помощью ключевого слова new, у нас в куче выделяется опред. участок памяти, участок выделяется в соответствии с 
            размером этого класса, у этого участка памяти есть какой-то адрес и адрес этого участка памяти помещается в стэк. Тоесть в 
            стеке хранится адрес участка памяти в куче.


            КОГДА мы вызываем МЕТОД и в качестве АРГУМЕНТА передаем ValueType - то мы выделяем так называемый фрэйм метода, это участок 
            памяти стэка куда передаются аргументы метода в виде дубликата, тоесть в стеке будет занята след. свободная ячейка памяти для
            фрейма метода тоесть его дубликатов аргументов, как следствие указатель в памяти перейдет на след. свободную ячейку в памяти 
            и после выхода из метода, фрейм метода удалится освободив ячейку в памяти и указатель в памяти снова вернется на одну ячейку 
            назад где был ранее фрейм метода.

            КОГДА мы вызываем МЕТОД и в качестве АРГУМЕНТА передаем Reference type - то мы в метод передаем ссылку(которая хранится в стеке)
            на экз. класса "C" (который хранится в куче). И к примеру после выхода из метода мы удалили переменную со ссылкой на наш 
            объект(экз. класса "C"), тоесть в стеке ссылки на наш экз. класса "C" более не существует, но в куче наш объект по прежнему
            остается и там занимает память и вот для этого и нужен Garbage Collection, чтобы удалять не нужные объекты из памяти, на 
            которые не ссылается ни одна ссылка. 
            

            Garbage Collection - собирает мусор тогда, когда CLR решает, что для работы приложения недостаточно памяти и она запускает
            GC. Перед работой GC, GC останавливает все приложение и обходит кучу и если на объект нету ссылку, он его удаляет. И далее
            он перезапысывает память упорядочивая объекты в памяти друг за другом, и именно поэтому приложение останавливается, тк ему 
            нужно перезаписывать ссылки, объекты по новым ячейкам в памяти упорядочивая ее. GC не проверяет все память каждый раз, тк
            было бы это трудозатратно, для этого были сделаны поколения: 0, 1, 2 - три поколения. Как только создается объект, когда мы
            пишем оператор new, создается объект внутри кучи, ему выделяется память, и для него устанавливается "0" поколение и когда 
            GC начинает свою работу, он в первую очередь проверяет новичков, тоесть "0" поколение, и проверяет есть ли на них ссылки, если
            ссылка есть, то этому объекту присваивается "1" поколение. Далее если CLR решает что памяти достаточно, то GC идет отдыхать, 
            но если памяти не достаточно, то уже начинается проверка по "1" поколению, тоесть "0" поколение проверели и теперь идем к 
            "1" поколению, тоесть идем к самым молодым и не проверенным, если ссылки есть то присваивается "2" поколение, если ссылок нет
            то объект удаляется. И после того как пережил объект 2 поколения, он становится "2" поколения, больше чем "2" поколения объекта
            быть не может. И таким образом работает GC. ОСНОВНАЯ ИДЕЯ в том - что чем дольше объект в памяти находится то тем меньше
            вероятность что его нужно удалять, гораздо больше шансов освоблодить память проходясь по молодым объектам. Чем моложе объект
            тем чаще он будет проверяться. Тоесть первый раз прошли проверили, у далили самые свежие, второй раз прошли проверили, и 
            удалили чуть более старых и третий раз прошли и проверили самых старых. 
            ? Непонятно - GC при каждом запуске начинает с "0" поколения и далее к "1" и "2" поколениям идет если памяти не достаточно, 
            или он при запуске продолжает с того места где остановлся в прошлый раз? - наверное при каждом запуске начинает с "0" тк 
            по принципу работы GC идея в том чтобы реже проверять самые старшые поколения.
            ? "0" поколение объекту присваивается при его создании или после первого прохода GC? - наверное при создании.

            Оператор new - занимается тем, что выделяет память под объект в куче.

            Где хранится static в стеке или куче:
              - если тип static значимый то хранится в стеке
              - если тип static ссылочный то хранится в куче
            static является root(корневым) элементом.

            Существует 2 вида кучи:
                1. Обычная куча - тут после оптимизации/освобождения памяти GC объекты перемещаются. 
                2. Большая куча (large object heap) - суда помещаются объекты примерно объемом 85мб.
            Отличие обычной и большой кучи - после оптимизации/освобождения памяти GC в большой кучи, не выполняется пермещение объектов,
            тоесть объекты так и остаются разбросаны по памяти.


            Финализатор (finalizer) - это по сути наш деструктор, объявляется как конструктор, но только с тильдой ~.

            */




            // Основные возможности работы с GC в классе GC
            // GC.Collect(2); //вручную вызываем GC для очистки памяти, а в аргументе можем передать номер поколения по которым произвести очистку
            // можем получить общий размер занятой памяти
            // можем узнать сколько раз GC проходил по памяти, тоесть делал очистку

            Console.WriteLine(GC.GetTotalMemory(false));  // выведем занятость памяти до цикла

            for (int i=0; i < 10000; i++)   //займем память объектами
            {
                var obj = (object)i;
                int j = (int)obj;
            }

            Console.WriteLine(GC.GetTotalMemory(false));  // выведем занятость памяти после цикла

            GC.Collect(); // вызовем очистку памяти

            Console.WriteLine(GC.GetTotalMemory(false));  // еще раз выведем занятость памяти после очистке GC





            // Финализатор - это по сути наш деструктор, объявляется как конструктор, но только с тильдой ~.
            // ДАЛЕЕ создали класс MyClass для демонстрации деструктора

            // Деструктор - это метод который будет вызываться в тот момент, когда экземпляр класса будет уничтожаться, и мы можем
            // самостоятельно определить его поведение, как с конструктором. К примеру если наш класс работает с потоком, мы можем в 
            // деструкторе описать корректное закрытие потока. Переопредиление финализатора достаточно редкое явление, это нужно делать
            // когда нам нужно определить дополнительное поведение перед тем как наш объект будет уничтожен. Деструктор не имеет модиф.
            // доступа и аргументов, вызвать вручную мы его не можем! Но если нужно сделать класс так, чтобы его можно было уничтожать 
            // вручную, то нужно имплементировать интерфейс MyClass: IDisposable, и интерфейс IDisposable имеет один метод Dispose(),
            // это позволит вручную уничтожать этот класс, и это еще позволит нам использовать экз. этого класса внутри конструкии
            // using()

            using (var c = new MyClass()) //тут среда не ругается, но если наш класс MyClass не будет реализовывать интерфейс IDisposable,
                                          //то тут будет ошибка, тк эта синтаксич. конструкция работает только с калссами которые реализуют
                                          //интерфейс IDisposable.
            {
                // и тут мы уже определяем поведение как наш объект будет уничтожен
            }
            // Основная фишка в том что, когда у нас заканчивается область видимости конструкции using, у нас будет автоматически вызван 
            // метод Dispose().





        }
    }
}
