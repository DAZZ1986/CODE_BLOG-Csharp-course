using System;
using System.IO;
using System.Text;

namespace CODE_BLOG__16_потоки_stream__и_файлы__file_
{
    class Program
    {
        static void Main(string[] args)
        {
            /*
            // Потоки (stream) и файлы (file) в C# - Учим Шарп #16
            // Для удобного взаимодействия с файлами был создан такой формат как stream (поток).

            // Директива using - позволяет создать объект который, будет доступен внутри данного блока кода. При выходе
            // из данного блока кода, объект будет уничножен, с помощью метода dispose. Метод Dispose закрывает канал
            // который мы открыли для работы с файлами, если канал не закрыть данные могут быть потеряны.
            // И как раз дериктива using она позволяет автоматически создать объект потока и автоматически вызывать
            // команду закрытия при выходе их этой области. Это удобно и гарантирует что вы не забудете закрыть поток.
            // Сигнатура:
            using (var sw = объявляем_объект) // тут объявляем объект потока
            {
                // Открыть файл, тоесть установить подключение, тоесть создать поток данных.
                // Прочитать/Записать
                // Закрыть поток данных
            }
            */


            // Запись
            // Объявляем объект потока, делаем Запись файла, создаем объект StreamWriter. Мы можем в поток StreamWriter передать любой
            // другой поток и оно будет записывать, но нам так не удобно, а проще указать путь к файлу(полный или не полный). Если
            // указывать не полный путь, то файл будет лежать рядом с .exe файлом.
            using (var sw = new StreamWriter("test16.txt", true, Encoding.UTF8)) //чтобы файл не перезапысывался с нуля, а дописывал новые
                   // данные, для этого нам нужно передать второй параметр типа bool append, по умолчанию false и файл перезаписывается.
                   // В качестве 3 параметра в конструктор можем передать кодировку.
            {
                // у объекта потока StreamWriter, ссылка на объект лежит в переменной sw мы можем вызвать метод WriteLine
                sw.WriteLine("Hi, user");
                sw.WriteLine("Артур");

            }


            // Чтение
            using (var sr = new StreamReader("test16.txt", Encoding.UTF8))
            {   
                
                // Чтение построчное EndOfStream
                while (!sr.EndOfStream)  // чтение файла построчно EndOfStream
                {
                    Console.WriteLine(sr.ReadLine() + " - чтение построчное");   // ReadLine у нас прочитает только одну строчку из потока
                }
                
                // Чтение всего файла ReadToEnd()
                sr.DiscardBufferedData();     // очищаем внутренний буфер
                sr.BaseStream.Seek(0, SeekOrigin.Begin); // тут мы обращаемся к основному потоку и у основного потока вызываем метод
                                                         // перехода в определенную позицию, тоесть переносим указатель в начало.
                string text = sr.ReadToEnd(); // чтение всего файла. Нюанс - когда мы второй раз вызываем команду на чтение всего файла
                                              // ReadToEnd (без обновления указателя на начало), она не отрабатывает, потому, что у нас
                                              // указатель на чтение уже стоит в самом конце файла, тк мы ранее делали построчное чтение.
                                              // Поэтому в переменную text ничего не попадет. Поэтому если мы хотим прочитать файл еще
                                              // раз, у класса StreamReader есть специальный метод sr.DiscardBufferedData(); и
                                              // BaseStream.Seek(0, SeekOrigin.Begin); которые перенесут указатель на начало файла.
                                              // А у класса FileStream.Seek есть метод Seek().
                Console.WriteLine(text);
            }






        }

    }
}
