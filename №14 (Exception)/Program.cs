using System;

namespace CODE_BLOG__14__Exception_
{
    class Program
    {
        static void Main(string[] args)
        {
            // Исключения (Exception) в C# - Учим Шарп #14
            // Все ожидаемые ошибки лучше обрабатывать с помощью условного оператора if, тк она не ресурсоемкая, и вообще там где это
            // возможно. Но непредвиденные ошибки которые влияют на работу системы и где мы явно должны сигнализировать пользователю
            // тут нужно испольщовать exeption. При работе с исключениями мы работаем по принципу наименьшего вреда. Как следствие, да
            // мы можем кинуть исключение, при этом не корректно завершено приложение, будет закрыто подключение, все данные сохранятся
            // и мы просто перезагрузим приложение и все ранее введеные данные будут восстановлены, просто продолжится с момента
            // возникновения ошибки, чтобы польователь все заново не заполнял - это нормальное поведение! Будет ужас если данные
            // вводили и после исключения все данные потерялись. Лучше контролируемое поведение, перезапуск итд.

            // синтаксис
            /*
            try
            {
                тут вставляем тот код который может содержать угрозу (тот код который хотим отловить, проконтролировать)
                если код исполняется то все ок, если что то идет ни так и мы получаем исключение, то мы проваливаемся в блок catch.
            }
            При отлове нескольких исключений, тоесть у нас будет несколько блоков catch, то сверху в блоках catch отлавливаем
            узкие/специализированные исключения и чем ниже тем шире берем диапазон исключений.
            catch(тип_исключения имя_переменной_исключения) - этот блок с параметрами не обязательный, можно и без него. Исключения бывают разные, и 
            1)если мы хотим отловить конкретное исключение то мы указываем его тип;
            2)если мы хотим получить доп. информацию по этому исключению мы используем имя переменной.;
            3)если мы хотим получить информацию почему что то пошло не так, посмотреть трасировку стека, посмотреть в каком методе, 
            библиотеке произошло исключение, все это мы можем получить из переменной "имя_переменной_исключения". Переменная не 
            обязательна, можно и в скобках указать только тип исключения и не записывать информацию об исключении в переменную.
            {
                тут мы ловим исключение, узнаем что пошло не так, можем его обработать, поправить, изменить, сообщить пользователю,
                записать в лог. Кол-во блоков catch может быть более 1.
            }
            finally     // этот блок finally является не обязательным.
            { 
                в блоке try может быть код помещен из 10 строк и если вылетит исключение на 2 строке мы переместимся в блок catch, 
                и как следствие мы никода не дойдем до 3 и последующих строк. И если мы хотим чтобы определенный код был выполнен 
                независимо от того была ошибка или нет, то мы этот код помещаем суда в блок finally. Чаще в данный блок заносятся
                такие работы как освобождение памяти, закрытие работы с потоками.
            }
            */




            // ОБРАЗЕЦ - ситуация с делением на 0.
            int ifiltr = 4;
            try
            {
                
                var i = 5;
                var j = i / 1;
                Console.WriteLine(j);
                
                int a = 2000000000;
                int b = 2000000000;
                //int c = checked(a * b);  // до этого исключения мы не дойдем тк поймаем его выше при делении на 0.
                //Console.WriteLine(c);


                //throw new DivideByZeroException();  // сами сгенерировали исключение без каких либо расчетов. С помощью ключа throw,
                                                      // мы создаем новый экземпляр эксепшона. Тоесть мы сами в этом месте генерируем
                                                      // исключение деления на 0 и попадаем в блок catch (DivideByZeroException ex).
                //throw new DivideByZeroException("Моя заметка");// сами сгенерировали исключение и передали нашу заметку в Message в
                                                               // нужный блок эксепшона.

                //throw new ArgumentNullException("i", "эта переменная вызвала исключение");  // тут можем узнать какая именно переменная вызвала исключение.
                
                //throw new MyOwnExeption();      // создали свое исключение и точно так же мы его генерируем
            }
            catch (MyOwnExeption ex)    // создали свое исключение
            {
                Console.WriteLine(ex.Message);
            }

            catch (DivideByZeroException ex) when (ifiltr == 5) // используем дополнительный фильтр при нескольких одинаковых исключениях
            {
                Console.WriteLine($"Деление на 0 и ifiltr = 5. {ex.Message}");
            }
            catch (DivideByZeroException ex) // конкретно это исключение отлавливает деление на 0. Тоесть мы сделали разделение по
                                             // типам исключений. И сверху нужно размещать более узкоспециализированные блоки catch
                                             // и в самом конце общий catch. 
            {
                Console.WriteLine($"Деление на 0. {ex.Message}");
            }

            catch (Exception ex)    // иногда бывает такое что exeption находится не в try как должно быть, а в catch.
            {
                Console.WriteLine($"Какое то исключение - {ex.Message}");
                //throw;  // тут мы логируем сообщение об ошибке, и прокидываем исключение на уровень выше, на интерфейс, мол далее
                //разбирайтесь сами. Мы с интерфейсом не работаем, иы отловили, залогировали, а будет ли оно обработано в интерфейсе
                //мы не знаем тк с интерфейсом не работаем.
            }
            finally
            {
                Console.WriteLine("Work stoped.");
                Console.ReadLine();
            }


            /*
            Содержание:
            // Образец исключения

            // 1. Несколько блоков catch мы можем использовать для отлова разных типов исключений.
            // При отлове нескольких исключений, тоесть у нас будет несколько блоков catch, то сверху в блоках catch отлавливаем
            // узкие/специализированные исключения и чем ниже тем шире берем диапазон исключений.
            catch
            catch
            catch
            catch

            // 2. Фильтрация исключений (дополнительная проверка)
            с помощью ключевого слова when можем делать дополнительные условия. Если int ifiltr = 5 мы попадаем в
            catch (DivideByZeroException ex) when (ifiltr == 5), а если int ifiltr = 6 или любое другое число то мы попадаем в обычный
            эксепшон деления на 0 catch (DivideByZeroException ex).

            // 3. Как создавать свои собственные исключения в данном случае мы создали класс MyOwnExeption
            Наше исключение MyOwnExeption должно быть наследником базового класса Exeption, но так же наследоваться можно от разных 
            исключений, не только от базового. Наш класс исключения должен реализовывать как минимум 1 конструктор без параметров.
            */







            /*
            // это вопрос от пользователя по поводу ввода с проверкой на корректность.
            int result22 = 0;
            while (true)
            {
                var input = Console.ReadLine();
                if (int.TryParse(input, out result22))
                {
                    Console.WriteLine($"Интовый {result22}");
                    break; // выход из цикла
                }
                else
                {
                    Console.WriteLine("Не корректный ввод введите целочисленное число.");
                }
            }
            Console.WriteLine(result22);
            Console.WriteLine(result22.GetType());
            */



        }
    }
}






