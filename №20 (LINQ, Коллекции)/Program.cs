using System;
using System.Collections.Generic;
using System.Linq;

namespace CODE_BLOG__20__LINQ__Коллекции_
{
    class Program
    {
        static void Main(string[] args)
        {
            // LINQ и работа с коллекциями в C# - Учим Шарп #20
            /*
            SQL - это язык запросов. Необходимо иногда из БД получать ни все данные, а какие то определенные, именно для этого и был создан
            язык запросов SQL, можем форматировать запрос и получать только те данные которые нам нужны. Но в языке С# писать на SQL нельзя,
            на самом деле можно, но это не удобно, тк мы работаем с классами и мы хотим с ними продолжать работать. И как раз для этого и 
            нужна библиотека LINQ.

            LINQ - это библиотека, которая позволяет манипулировать коллекциями данных. Она предоставляет большие возможности для работы с 
            данными. Если нам нужны данные только мужчины, то мы указываем параметр и получаем ни всех людей, а потом их обрабатываем, а 
            получаем конкретный набор с только мужчинами. Можем делать составные запросы, все девушек от 18 до 25 лет. Мы можем делать это 
            и на SQL, но для программиста C# в LINQ делать это удобнее, потому, что он работает не одним запросом, а работает с классами. 
            
            Что мы можем делать с коллекциями с помощью LINQ:
            1. Мы можем преобразовывать один класс в другой класс.
            2. Мы можем накладывать условия на выборку, тоесть выбирать ни все элементы из коллекции, а только те которые удовлетворяют условию.
            3. Мы можем упорядочивать коллекцию. (по нескольким полям).
            4. Мы можем делать группировку - разбивать одну коллекцию элементов на отдельные коллекции.
            5. Мы можем объединять коллекции.
            6. Мы можем манипулировать коллекциями как множествами(объединение, вычитание, перисечение). (это из дискретной математики).
            7. Мы можем выполнять агрегатные операции - суммирование, посчитать среднее, найти максимальный, минимальный эл. в коллекции.
            8. Мы можем получать единичный элемент из коллекции, первый элемент или последний итд.

            LINQ позволяет работать с несколькими типами коллекций:
            1. Может работать с наборами данных из Entity Framework.
            2. Может работать с любыми классами которые реализуют интерфейс IEnumerable, с любыми коллкциями.
            3. Может работать с xml.
            */


            // Делаем коллекцию в виде простого списка List.
            var collection = new List<int>(0);

            for (int i = 0; i < 10; i++)
            {
                collection.Add(i);
            }



            // У LINQ есть 2 формы записи: 1) стандартная и 2) форма которая выглядит в виде методов расширений.

            // Методы расширений - это методы которые добавляются поверх класса, без создания наследника и он не содержится внутри класса.
            // Тоесть есть класс, а сверху к нему приляпали метод, и он класса расширяет функционал класса. По сути это синтаксический сахар.
            // Просто в качестве одного из аргументов, он принимает сам объект класса.

            // 1. Стандартная форма записи, мы хотим получить из коллекции только элементы менее 5.
            // тут как в foreach, по очереди будут помещаться все эл. коллекции, item это эл. коллекции.
            var result = from item in collection
                         where item < 5  //тут добавляем условие. ВАЖНО!!! если используем where, то она всегда возвращает коллекцию либо null.
                         select item;    //и говорим что нужно с этим эл. сделать - нам его нужно взять/выбрать.

            // на выходе имеем коллекцию IEnumerable.
            foreach (var item in result)
            {
                Console.WriteLine(item);
            }


            // 2. Запишем по 2 форме записи - с методами расширений (в выпадающем списке методов, будут методы со стрелочкой, это означает,
            // что это не радной метод класс, а приляпаный метод расширения.)
            var result2 = collection.Where(item => item < 5); // расшифровка записи Where(item => item < 5) - где, item такой что, item < 5.
                                                              // тоесть выбрать такие элементы которые менее 5.
                                                              // плюс методов расширений в том что мы можем продолжить колбасу условий разделенную точками.
                                                              // на выходе имеем коллекцию IEnumerable.
            foreach (var item in result2)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");
            
            // тут мы выбрали те которые менее 5 и из них мы выбираем те которые четные и далее упорядочиваем в обратном направлении (OrderByDescending).
            var result3 = collection.Where(item => item < 5)
                                    .Where(item => item % 2 == 0)
                                    .OrderByDescending(item => item);
            foreach (var item in result3)
            {
                Console.WriteLine(item);
            }






            Console.WriteLine("|||||||ДАЛЕЕ усложним работу и сделаем дополнительный класс Product");

            // ДАЛЕЕ усложним работу и сделаем дополнительный класс Product.
            // Делаем коллекцию типа Product
            var collection2 = new List<Product>(0);
            var rnd = new Random();

            for (int i = 0; i < 10; i++)
            {
                var product = new Product()
                {
                    Name = "Продукт " + i,
                    Energy = rnd.Next(10, 500)
                };
                collection2.Add(product);
            }

            var result4 = from item in collection2
                          where item.Energy < 200 || item.Energy > 800   // тут добавляем условие
                          select item;  // тут говорим какой тип нам будет возвращен. Можем указать и так item.Energy и вернется int

            var result5 = collection2.Where(item => item.Energy < 2000 || item.Energy > 8000);

            // делаем вывод
            foreach (var item in result4)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");
            foreach (var item in result5)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ Делаем операцию SELECT - это преобразование одного типа в другой.
            // сейчас сделаем из списка продуктов, сделаем список целых числе оставив только Energy

            // Делаем коллекцию в виде простого списка List
            var productsCollect = new List<Product>(0);

            for (int i = 0; i < 10; i++)
            {
                var product10 = new Product()
                {
                    Name = "Продукт " + i,
                    Energy = rnd.Next(10, 12)
                };
                productsCollect.Add(product10);
            }

            var selectCollection = productsCollect.Select(product => product.Energy);//тут взяли продукты, вытащили Енерг. ценност и положили
                                                                                     //в новую коллекцию и так наполнили новую коллекцию.
            Console.WriteLine("Коллекция с энергетическими ценностями продуктов:");
            foreach (var item in selectCollection)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");





            // ДАЛЕЕ мы можем упорядочить нашу коллекцию по возрастанию при помощи команды - orderby item.Energy
            Console.WriteLine("Упорядочили через orderby");
            var result6 = from item in collection2
                          where item.Energy < 2000 || item.Energy > 8000   // тут добавляем условие
                          orderby item.Energy
                          select item;

            foreach (var item in result6)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");

            Console.WriteLine("Упорядочили через OrderBy");
            var orderbyCollection = productsCollect.OrderBy(product => product.Energy) // тут упорядочили по энерг ценности
                                                    .ThenByDescending(product => product.Name); // после ценности, тут упорядочилди по имени

            foreach (var item in orderbyCollection)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ Группировка - разбиение нашей коллекции на группы. (это можно сделать и через SQL и через LINQ)
            var productsCollect2 = new List<Product>(0);

            for (int i = 0; i < 10; i++)
            {
                var product10 = new Product()
                {
                    Name = "Продукт " + i,
                    Energy = rnd.Next(10, 12)
                };
                productsCollect2.Add(product10);
            }

            var groupbyCollection = productsCollect2.GroupBy(product => product.Energy);
            // И после этой команды выше, он возвращает коллекцию не IEnumerable, а возвращает группированый элемент. Это так называемый
            // "Список с висюльками" - это означает что у нас есть список и за каждым элементом списка закреплена коллекция. И для вывода
            // нам нужно перебирать его с помощью цикла.

            foreach (var keyitem in groupbyCollection)  //тут элемент item это пара, в котрой первый элемент является ключем, а второй
                                                        //является коллекцией этого ключа. Ключ типа int, а коллекция типа <Product>.
            {
                Console.WriteLine($"Key: {keyitem.Key}");
                foreach (var item in keyitem)
                {
                    Console.WriteLine($" \t{item}");
                }
                Console.WriteLine();
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");







            // ДАЛЕЕ делаем операцию Реверс - переворот в обратном порядке
            Console.WriteLine("Вывод коллекции ДО реверса");
            foreach (var item in productsCollect2)
            {
                Console.WriteLine(item);
            }

            productsCollect2.Reverse(); // тут переворачиваем список и он таким останется навсегда.

            Console.WriteLine("Вывод коллекции ПОСЛЕ реверса");
            foreach (var item in productsCollect2)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");




            // ДАЛЕЕ 2 частые операции All и Any - они возвращают уже не элемент коллекции, а возвращают уже bool значение.
            // All - возвращает true, если соответственным условиям соответствуют все элементы коллекции. Н/П: если у всех продуктов энерг.
            // ценность будет равна 10, то вернет true.
            // Any - если хотя бы один элемент коллекции соответствует условию, то нам вернется true.
            Console.WriteLine("All и Any");

            var all = productsCollect2.All(item => item.Energy == 10);
            Console.WriteLine(all);
            var any = productsCollect2.Any(item => item.Energy == 10);
            Console.WriteLine(any);

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");





            // ДАЛЕЕ операция Contains (содержит) - проверяет вхождение элемента в коллекцию. 
            Console.WriteLine("Contains");
            var contains = productsCollect2.Contains(productsCollect2[5]); // тут выведится true, тк этот элемент принадлежит этой коллекции.
            Console.WriteLine(contains);

            var prod = new Product(); // тут созхдали продукт не из коллекции и теперь должно быть false, тк эл. в коллекции такого нет.
            var contains2 = productsCollect2.Contains(prod);
            Console.WriteLine(contains2);





            // ДАЛЕЕ операция distinct - позволяет нам делать коллекцию из уникальных элементов удаляя все дублирующие элементы.
            // Н/П: если у нас в коллекции будут значения 1, 2, 3, 1, 2, 3 - то на выходе мы получим 1, 2, 3.



            Console.WriteLine("||||ДАЛЕЕ операции со множествами (объединение, вычитание, перисечение)");
            // ДАЛЕЕ операции со множествами (объединение, вычитание, перисечение)
            // Объединение Union
            var array = new int[] { 1, 2, 3, 4 };
            var array2 = new int[] { 3, 4, 5, 6 };

            Console.WriteLine("Вывод простого списка");
            foreach (var item in array)         // тут делаем вывод до объединения
            {
                Console.WriteLine(item);
            }

            var union = array.Union(array2);    // тут делаем объединение и сразу он делает по умолчанию distinct(удаляет дубли в коллеции)
            Console.WriteLine("Вывод объединенного списка");
            foreach (var item in union)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ операция Intersect - выводит дублирующиеся/повторяющиеся элементы в двух коллекциях.
            var intersect = array.Intersect(array2);
            Console.WriteLine("Вывод Intersect");
            foreach (var item in intersect)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ операция Except - выводит те элементы которые есть в первой коллекции/множестве, но нет во второй. (тоесть уникальные
            // значения первого множества). Тоесть мы из первого множества, вычли второе множество. И так же можем сделать наоборот, из
            // второго множества вычесть первое, просто поменяв местами имена множеств в коде - array2.Except(array);
            var except = array.Except(array2);
            Console.WriteLine("Вывод Except");
            foreach (var item in except)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ агрегатная операция - можем подсчитать сумму
            Console.WriteLine("агрегатная операция");
            var sum = array.Sum();
            var min = productsCollect2.Min(p => p.Energy);  // тут мы выбрали бы минимальный продукт по энергетической ценности
            var max = productsCollect2.Max(p => p.Energy);

            // так же мы можем задавать произвольные агрегатные функции с помощью метода aggregate
            var aggregate = array.Aggregate((x, y) => x * y);   // так мы получим когда каждый элемент будет умножаться друг на друга последовательно
            
            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ если мы хотим взять сумму ни всех элементов массива, а мы хотим пропустить первый элемент и далее взять два следующих
            Console.WriteLine("агрегатная операция Skip");  // Skip - мы задаем сколько элементов нам нужно пропустить
            var sum2 = array.Skip(1).Sum(); //в данном случае у нас будет взят ни весь массив { 1, 2, 3, 4 }, а все элементы кроме первого. 
            var sum3 = array2.Skip(2).Sum();//в данном случае у нас будет взят ни весь массив { 3, 4, 5, 6 }, а все элементы кроме первых двух. 
            Console.WriteLine(sum3);

            Console.WriteLine("агрегатная операция Take");  // Take - мы задаем сколько элементов нам нужно взять
            var sum4 = array.Skip(1).Take(2).Sum(); //массив { 1, 2, 3, 4 }, тут мы пропустили первый элемент и суммировали 2 последующих.
            Console.WriteLine(sum4);

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ если мы хотим взять из всей коллекции 1 элемент - это мы можем сделать 4 способами.
            // First() - берет из коллекции первый элемент, но если коллекция пуста, словим эксепшон, чтобы не ловить эксепшон, нужно
            // FirstOrDefault() использовать, тогда при пустой коллекции подставит значение по умолчанию для данного типа.
            Console.WriteLine("FirstOrDefault");
            var first = array2.FirstOrDefault();    // если where нам возвращают коллекцию, пустую или с 1 элементом не важно, но коллекцию
                                                    // то вот эти операции First(), Last() нам возвращают конкретный элемент.
            var last = array2.Last(); // тоже самое и с Last.
            Console.WriteLine(last);
            // Если в вашем приложении ожидаемо должно, что то быть то берем First, Last, ф если непонятно то FirstOrDefault, LastOrDefault.


            var first2 = productsCollect2.First(p => p.Energy == 10);  // тут мы из всей коллекции берем первый элемент у которого
                                                                       // энергетическая ценнтость будет равна 10. Их может быть
                                                                       // несколько с ценностью в 10, но мы возьмем первый.
            //var single = productsCollect2.Single(p => p.Energy == 10);  // отличие от операции First(p => p.Energy == 10) в том, что
                                                                        // если в коллекции будет два элемента с энерг. ценностью 10, то
                                                                        // мы получим эксепшон, в то время как First() просто берет первый
                                                                        // попавшийся элемент.
            Console.WriteLine(first2);

            Console.WriteLine("||||||||||||||||||||||||||||||||||||||||||||||||||||||||");






            // ДАЛЕЕ операция ElementAt - это получение элемента по индексу. 
            Console.WriteLine("elementAt");
            var elementAt = productsCollect2.ElementAt(5);
            Console.WriteLine(elementAt);











        }
    }
}
