using System;
using System.Collections.Generic;

namespace CODE_BLOG_Индексаторы__Indexer__и_Итераторы__yield_._Интерфейс_IEnumerable
{
    class Program
    {
        static void Main(string[] args)
        {
            // Индексаторы (Indexer) и Итераторы (yield). Интерфейс IEnumerable в C# - Учим Шарп #22

            /*
            Индексаторы - это запросы к коллекции. Обертка для более удобной работы с коллекциями. 
            Н/П: У нас есть большой объект, который содержит внутри себя много маленьких объектов и можно писать много методов для доступа
            к маленьким объектам, а индексаторы позволяют непосредственно обращаясь к большому объекту, выдергивать маленькие объекты.


            Например у нас есть объект, который может содержать в себе какое то кол-во элементоров этого или какого либо другого класса и для
            того чтобы, обращаться к этим вложенным элементам внутри класса по индексу. (как к эл. массива)
            Н/П где может применяться индексатор: у нас есть класс Парковка и внутри этой парковки может содержаться большое кол-во 
            машин/элементов. Мы сможет обращаться к конкретной машине просто по ее номеру либо по ее индексу и это мы сами будем задавать 
            по какому признаку мы будем искать элемент. Обычно используют поиск по номеру. Но можем переопределить и искать не по номеру, а
            по ключу или по нескольким признакам. 

            // Объявляем индексатор
            // Можно делать индексатор только для чтения, только get, можем задавать модиф. доступа для get и set, вообщем все как с обычными свойствами.
            // СИГНАТУРА  -  модификатор_доступа тип this[тип_аргумента индекс]
            public int this[string number]
            {
                get
                {
                
                }
                set
                { 
                
                }
            }
            */

            // Индексаторы (объявление и работа)
            // ДАЛЕЕ создадим класс Parking и класс Car

            // ДАЛЕЕ создадим пару авто
            List<Car> cars = new List<Car>()
            {
                new Car(){ Name = "Ford", Number = "A001AA01"},
                new Car(){ Name = "Lada", Number = "B727ET77"},
            };

            // ДАЛЕЕ создадим нашу парковку
            Parking parking = new Parking();   // тут мы создали экз. класса

            foreach (var item in cars)
            {
                parking.Add(item);  // тут через экз. класса дотянулись до метода Add(), а в методе Add() мы добавляем экземпляр в
                                    // коллекцию List<Car> _cars.
            }



            Console.WriteLine("||||||ТЕПЕРЬ суть темы - Как обратиться к автомобилю?");
            // ТЕПЕРЬ суть темы - Как обратиться к автомобилю? Делать публичный List<Car> _cars неправильно, поэтому используем индексатор,
            // и обратимся к элементам коллекции по индексу который мы сами и определим. Как мы это делаем, далее см. файл Parking -
            // "Объявляем индексатор".

            Console.WriteLine(parking["A001AA01"].Name);  //тут мы передали рег.номер авто в индексатор, а в индексаторе в get сделали
                                                          //поиск авто по номеру в коллекции _cars.FirstOrDefault(c => c.Number == number);
            Console.WriteLine(parking["A001AA02"]?.Name); // для текста вывели не существующий авто и поставили знак ? чтобы не вылетел
                                                          // эксепшон, тк авто в коллекции нет.

            // Что мы сделали - мы передали в качестве аргумента значение "A001AA01", оно упало в параметр [string number] и в Индексаторе
            // сказали, что ищем совпадения в содержащейся внутри коллекции по данному значению (c => c.Number == number); и когда мы
            // получили эл. коллекции, мы его просто возвращаем. По сути просто через индексатор вывели эл. коллекции и дали посмотреть
            // польхзователю, при этом мы его не добавляли и не удаляли.
            // Так же мы можем делать перегрузку индексаторов, их может быть несколько, если они будут отличаться по принимаемому аргументу.


            Console.WriteLine("||||||ДАЛЕЕ Перегрузка индексаторов");
            foreach (var item in parking)   // просто выведем коллекцию до замены авто на парковке
            {
                Console.WriteLine(item);
            }
            // ДАЛЕЕ Перегрузка индексаторов - они должны отличаться принимаемыми аргументами, либо их кол-вом, либо их типами.
            // в данном случае мы с парковки из конкретной позиции можем авто выдернуть и в это место поставить другую
            Console.WriteLine("Введите номер нового автомобиля");
            var num = Console.ReadLine();
            parking[1] = new Car() { Name = "BMW", Number = num };
            Console.WriteLine(parking[1]);




            Console.WriteLine("|||||ДАЛЕЕ как получить машины обращаясь к парковке не через индексатор, а с помощью foreach");
            // ДАЛЕЕ как получить машины обращаясь к парковке не через индексатор, а с помощью foreach для этого нужно сделать так, 
            // чтобы наш класс Parking реализовывал интерфейс IEnumerable, Parking : IEnumerable
            foreach (var item in parking)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine();





            Console.WriteLine("|||||ДАЛЕЕ Итераторы (yield) - мы можем самостоятельно быстро реализовывать наши коллекции");
            // Итераторы (yield) это синтаксический сахар, который нам позволяет избавиться от всей реализации класса с влож. методами
            // public class ParkingEnumerator : IEnumerator , когда мы не используем готовый класс реализующий интерфейс, но хотим
            // самостоятельно реализовать этот доступ для пересчета эл. коллекции, мы можем использовать ключевое слово yield. Это
            // означает что мы будем возвращать сразу коллекцию. Нам необходимо определить поведение как будет формировать коллекция.
            // Особенность yield - не вычисляется вся последовательность сразу. Yield по сути на возвращает перечислитель.

            // делаем публичный метод в классе Parking - public IEnumerator GetEnumerator()
            // перебираем имена авто
            foreach (var item in parking)
            {
                Console.WriteLine(item + " ");
            }

            // делаем публичный метод в классе Parking - public IEnumerable GetNames()
            // перебираем имена авто
            foreach (var item in parking.GetNames())
            {
                Console.WriteLine("Имя: " + item);
            }

            // Тоесть мы можем создавать те наборы перечислений, которые нам самим нужны, и мы можем сделать возможность получения ни
            // просто авто, а каких то частей авто. Выборка сразу всех авто под каким то условием. Это позволяет достигать гибкости в
            // приложении.





        }
    }
}
